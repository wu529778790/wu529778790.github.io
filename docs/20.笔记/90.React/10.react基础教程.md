---
title: react基础教程
date: 2020-11-08 14:35:56
permalink: /pages/b360d8fb74ce7/
categories:
  - 笔记
  - React
tags:
  - 
---


<https://zh-hans.react.dev/learn/start-a-new-react-project>

<!-- more -->

## 环境搭建

create-react-app

```bash
npx create-react-app my-app
cd my-app
npm start
```

## JSX

JSX 是 JavaScript 的语法扩展。React 使用 JSX 来替代常规的 JavaScript。浏览器不能直接解析JSX，需要使用babel进行编译

<https://babeljs.io/repl/#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&build=&builtIns=false&corejs=3.21&spec=false&loose=false&code_lz=DwEwlgbgfAUAkAFwBZgM4AI3vBGwD0OUQA&debug=false&forceAllTransforms=false&modules=false&shippedProposals=false&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=env%2Creact%2Cstage-2&prettier=false&targets=&version=7.26.2&externalPlugins=&assumptions=%7B%7D>

![20241108144358](https://gcore.jsdelivr.net/gh/wu529778790/image/blog/20241108144358.png)

### 在 jsx 中可以通过 {} 来使用 js 表达式，但是不能使用 if else 语句，可以使用三元运算符

`if语句、switch语句、变量声明属于语句，不是表达式，不能出现在{}中`

### jsx 中可以使用map实现列表渲染

```jsx
const list = [1, 2, 3, 4, 5];
const listItems = list.map((item) => <li>{item}</li>);
```

### jsx 中实现条件渲染

在React中，可以通过逻辑与运算符&&、三元表达式（?:）实现基础的条件渲染

```jsx
const isLogin = true;
const element = isLogin ? <div>登录成功</div> : <div>登录失败</div>;
```

### jsx 实现复杂条件渲染

列表中需要根据文章状态适配三种情况，单图，三图，和无图三种模式

自定义函数 + if判断语句

```jsx
function getArticleType(article) {
  if (article.images.length === 1) {
    return <div>单图</div>;
  } else if (article.images.length === 3) {
    return <div>三图</div>;
  } else {
    return <div>无图</div>;
  }
}
```

## 事件绑定

on + 事件名称 = { 事件处理程序 }，整体上遵循驼峰命名法

### 使用时间对象参数

在事件回调函数中设置形参e

```jsx
function App() {
  function handleClick(e) {
    console.log(e);
  }
  return (
    <div>
      <button onClick={handleClick}>点我</button>
    </div>
  );
}
```

传递自定义参数

事件绑定的位置改造成箭头函数的写法，在执行clickHandler实际处理业务函数的时候传递实参

```jsx
function App() {
  function handleClick(name) {
    console.log(name);
  }
  return (
    <div>
      <button onClick={() => handleClick("wu")}>点我</button>
    </div>
  );
}
```

> 不能直接写函数调用，这里事件绑定需要一个函数引用，而不是函数调用，所以需要使用箭头函数

### 同时传递事件对象和自定义参数

```jsx
function App() {
  function handleClick(e, name) {
    console.log(e, name);
  }
  return (
    <div>
      <button onClick={(e) => handleClick(e, "wu")}>点我</button>
    </div>
  );
}
```

## useState

useState 是一个 React Hook（函数），它允许我们向组件添加一个状态变量, 从而控制影响组件的渲染结果.

本质：和普通JS变量不同的是，状态变量一旦发生变化组件的视图UI也会跟着变化（数据驱动视图）

```jsx
const [count, setCount] = useState(0); // count 是状态变量，setCount 是修改状态变量的方法
```

1. useState是一个函数，返回值是一个数组
2. 数组中的第一个参数是状态变量，第二个参数是set函数用来修改状态变量
3. useState的参数是状态变量的初始值

### 状态不可变

在React中，状态被认为是只读的，我们应该始终替换它而不是修改它，直接修改状态不能引发视图更新

```jsx
const [count, setCount] = useState(0);
const handleClick = () => {
    count = count + 1; // 错误写法
    setCount(count + 1); // 正确写法
};
```

### 修改对象状态

```jsx
const [person, setPerson] = useState({ name: "wu", age: 18 });
const handleClick = () => {
    person.age = "19"; // 错误写法
    setPerson({ ...person, age: 19 }); // 正确写法
};
```

## 组件的样式处理

React组件基础的样式控制有俩种方式

### 内联样式

```jsx
<div style={{ color: "red" }}>hello world</div>
```

### class样式

```jsx
<div className="red">hello world</div>
```

## 组件通讯

### 父子

props 可传递任意的数据

数字、字符串、布尔值、数组、对象、函数、组件(jsx)

```jsx
<Child name="wu" age={18} />
```

props 是只读的，不能直接修改

```jsx
props.name = "wu2"; // 错误写法
```

> 特殊的父传子

当我们把内容嵌套在子组件中时，子组件的props中会自动接收到父组件传递过来的内容，放到props.children中

```jsx
<Child>
    <div>hello world</div>
</Child>

console.log(props.children); // 打印 hello world
```

### 子父

子组件通过调用父组件传递过来的方法，来修改父组件中的状态变量

```jsx
function Parent() {
    const [count, setCount] = useState(0);
  return <Child setCount={setCount} count={count} />;
}

function Child(props) {
    return <button onClick={() => props.setCount(props.count + 1)}>点我</button>
}
```

### 兄弟

兄弟组件之间不能直接通讯，需要通过共同的父组件来实现通讯

![20241111173353](https://gcore.jsdelivr.net/gh/wu529778790/image/blog/20241111173353.png)

> 使用状态提升实现兄弟组件通讯

1. A组件先通过子传父的方式把数据传给父组件App
2. App拿到数据后通过父传子的方式再传递给B组件

> 使用context机制实现跨层级组件通讯

![20241111173500](https://gcore.jsdelivr.net/gh/wu529778790/image/blog/20241111173500.png)

1. 使用createContext方法创建一个上下文对象Ctx
2. 在顶层组件（App）中通过 Ctx.Provider 组件提供数据
3. 在后代组件中通过 Ctx.Consumer 组件消费数据

## useEffect

useEffect 是一个 React Hook（函数），用于在React组件中创建不是由事件引起而是由渲染本身引起的操作（副作用）,比如发送AJAX请求，更改DOM等等。

![20241111173702](https://gcore.jsdelivr.net/gh/wu529778790/image/blog/20241111173702.png)

上面的组件中没有发生任何的用户事件，组件渲染完毕之后就需要和服务器要数据，整个过程属于“只由渲染引起的操作”，所以需要使用useEffect来实现

### 基础使用

在组件渲染完毕之后，立刻从服务端获取频道列表数据并显示到页面中

```jsx
useEffect(() => {
    axios.get("https://api.shenzjd.com").then((res) => {
        console.log(res);
    });
}, []);
```

参数1是一个函数，可以把它叫做副作用函数，在函数内部可以放置要执行的操作
参数2是一个数组（可选参），在数组里放置依赖项，不同依赖项会影响第一个参数函数的执行，`当是一个空数组的时候，副作用函数只会在组件渲染完毕之后执行一次`

### useEffect 依赖项参数说明

| 依赖项 | 副作用函数执行情况 |
| ------ | ------------------ |
| 没有依赖项 | 组件初始渲染 + 组件更新时执行 |
| 空数组 | 只在初始渲染时执行一次 |
| 添加特定依赖项 | 组件初始渲染 + 特性依赖项变化时执行 |

### 清除副作用

在useEffect中编写的由渲染本身引起的对接组件外部的操作，社区也经常把它叫做副作用操作，比如在useEffect中开启了一个定时器，我们想在组件卸载时把这个定时器再清理掉，这个过程就是清理副作用

```jsx
useEffect(() => {
    const timer = setInterval(() => {
        console.log("hello world");
    }, 1000);
    return () => {
        clearInterval(timer);
    };
}, []);
```

说明：清除副作用的函数最常见的执行时机是在组件卸载时自动执行

## 自定义hook

自定义Hook是以 use 打头的函数，通过自定义Hook函数可以用来实现逻辑的封装和复用

![20241111174416](https://gcore.jsdelivr.net/gh/wu529778790/image/blog/20241111174416.png)

## React Hooks 使用规则

1. 只能在组件中或者其他自定义Hook函数中调用
2. 只能在组件的顶层调用，不能嵌套在 if、for、其他函数中

![20241111174804](https://gcore.jsdelivr.net/gh/wu529778790/image/blog/20241111174804.png)

## redux 快速上手

Redux 是React最常用的集中状态管理工具，类似于Vue中的Pinia（Vuex），可以独立于框架运行作用：通过集中管理的方式管理应用的状态

![20241111174859](https://gcore.jsdelivr.net/gh/wu529778790/image/blog/20241111174859.png)

为了职责清晰，数据流向明确，Redux把整个数据修改的流程分成了三个核心概念，分别是：state、action和reducer

1. state - 一个对象 存放着我们管理的数据状态
2. action - 一个对象 用来描述你想怎么改数据
3. reducer - 一个函数 更具action的描述生成一个新的state

![20241111174941](https://gcore.jsdelivr.net/gh/wu529778790/image/blog/20241111174941.png)
