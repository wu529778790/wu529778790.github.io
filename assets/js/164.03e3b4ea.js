(window.webpackJsonp=window.webpackJsonp||[]).push([[164],{499:function(a,t,s){"use strict";s.r(t);var e=s(4),n=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",{attrs:{"data-nodeid":"76796"}},[a._v("时至今日，Tree Shaking 对于前端工程师来说，已经不是一个陌生的名词了。顾名思义：Tree Shaking 译为“摇树”，它通常用于描述移除 JavaScript 上下文中的未引用代码（dead-code）。")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76797"}},[a._v("据我观察，Tree Shaking 也经常出现在诸多候选人的简历当中。然而可惜的是，大部分候选人都知道 Tree Shaking 的定义，但“知其然不知其所以然”，并没有在工程中真正实践过 Tree Shaking 技术，更没有深入理解 Tree Shaking 这个概念。社区上一些好的文章，比如"),t("a",{attrs:{href:"https://github.com/wuomzfx/tree-shaking-test","data-nodeid":"76953"}},[a._v("《你的 Tree-Shaking 并没什么卵用》")]),a._v("发布于 2018 年初，但就目前来看，其中内容也有些“过期”了。")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76798"}},[a._v("这一节，就让我们真正深入学习 Tree Shaking 这个概念。")]),a._v(" "),t("h3",{attrs:{"data-nodeid":"76799"}},[a._v("Tree Shaking 必备理论")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76800"}},[a._v("Tree Shaking 概念很好理解，这个词最先在 Rollup 社区流行，后续蔓延到整个前端生态。Tree Shaking 背后的理论知识独成体系，我们先从其原理入手，试着分析并回答以下问题。")]),a._v(" "),t("h4",{attrs:{"data-nodeid":"76801"}},[a._v("问题一：Tree Shaking 为什么要依赖 ESM 规范？")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76802"}},[a._v("事实上，Tree Shaking 是在编译时进行无用代码消除的，因此它"),t("strong",{attrs:{"data-nodeid":"76964"}},[a._v("需要在编译时确定依赖关系")]),a._v("，进而确定哪些代码可以被“摇掉”，而 ESM 具备以下特点：")]),a._v(" "),t("ul",{attrs:{"data-nodeid":"76803"}},[t("li",{attrs:{"data-nodeid":"76804"}},[t("p",{attrs:{"data-nodeid":"76805"}},[a._v("import 模块名只能是字符串常量")])]),a._v(" "),t("li",{attrs:{"data-nodeid":"76806"}},[t("p",{attrs:{"data-nodeid":"76807"}},[a._v("import 一般只能在模块的最顶层出现")])]),a._v(" "),t("li",{attrs:{"data-nodeid":"76808"}},[t("p",{attrs:{"data-nodeid":"76809"}},[a._v("import binding 是 immutable 的")])])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76810"}},[a._v("这些特点使得 ESM 具有静态分析能力。而"),t("strong",{attrs:{"data-nodeid":"76973"}},[a._v("CommonJS 定义的模块化规范，只有在执行代码后，才能动态确定依赖模块")]),a._v("，因此不具备 Tree Shaking 的先天条件。")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76811"}},[a._v("在传统编译型语言中，一般由编译器将无用代码在 AST（抽象语法树）中删除，而前端 JavaScript 并没有正统“编译器”这个概念，那么 Tree Shaking 就需要在工程链中由工程化工具完成。")]),a._v(" "),t("h4",{attrs:{"data-nodeid":"76812"}},[a._v("问题二：什么是副作用模块，如何对副作用模块进行 Tree Shaking?")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76813"}},[a._v("如果你熟悉函数式开发理念，可能听说过“副作用函数”，但什么是“副作用模块”呢？它又和 Tree Shaking 有什么关联呢？很多人清楚的 Tree Shaking 只是皮毛，而并不清楚 Tree Shaking 并不能“摇掉”副作用模块，具体我们看这样一段代码：")]),a._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"76814"}},[t("code",{attrs:{"data-language":"java"}},[t("span",{staticClass:"hljs-function"},[a._v("export function "),t("span",{staticClass:"hljs-title"},[a._v("add")]),t("span",{staticClass:"hljs-params"},[a._v("(a, b)")]),a._v(" ")]),a._v("{\n "),t("span",{staticClass:"hljs-keyword"},[a._v("return")]),a._v(" a + b\n}\nexport "),t("span",{staticClass:"hljs-keyword"},[a._v("const")]),a._v(" memoizedAdd = window.memoize(add)\n")])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76815"}},[a._v("当该模块被 import 时，"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"76978"}},[a._v("window.memoize")]),a._v("方法会被执行，那么对于工程化工具（比如 Webpack）来说，分析思路是这样的：")]),a._v(" "),t("ul",{attrs:{"data-nodeid":"76816"}},[t("li",{attrs:{"data-nodeid":"76817"}},[t("p",{attrs:{"data-nodeid":"76818"}},[a._v("创建一个纯函数"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"76981"}},[a._v("add")]),a._v("，如果没有其他模块引用"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"76983"}},[a._v("add")]),a._v("函数，那么"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"76985"}},[a._v("add")]),a._v("函数可以被 Tree Shaking 掉；")])]),a._v(" "),t("li",{attrs:{"data-nodeid":"76819"}},[t("p",{attrs:{"data-nodeid":"76820"}},[a._v("接着调用"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"76988"}},[a._v("window.memoize")]),a._v("方法，并传入"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"76990"}},[a._v("add")]),a._v("函数作为其参数；")])]),a._v(" "),t("li",{attrs:{"data-nodeid":"76821"}},[t("p",{attrs:{"data-nodeid":"76822"}},[a._v("工程化工具（比如 Webpack）并不知道"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"76993"}},[a._v("window.memoize")]),a._v("方法会做什么事情，也许"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"76995"}},[a._v("window.memoize")]),a._v("方法会调用"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"76997"}},[a._v("add")]),a._v("函数，并触发某些副作用（比如维护一个全局的 Cache Map）；")])]),a._v(" "),t("li",{attrs:{"data-nodeid":"76823"}},[t("p",{attrs:{"data-nodeid":"76824"}},[a._v("工程化工具（比如 Webpack）为了安全起见，即便没有其他模块依赖的"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77000"}},[a._v("add")]),a._v("函数，那么也要将"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77002"}},[a._v("add")]),a._v("函数打包到最后的 bundle 中。")])])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76825"}},[a._v("因此，具有副作用的模块难以被 Tree Shaking 优化，即便开发者知道"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77005"}},[a._v("window.memoize")]),a._v("方法是无副作用的。")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76826"}},[a._v("为了解决“具有副作用的模块难以被 Tree Shaking 优化”这个问题，Webpack 给出了自己的方案，我们可以利用 package.json 的"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77008"}},[a._v("sideEffects")]),a._v("属性来告诉工程化工具哪些模块具有副作用，哪些剩余模块没有副作用，可以被 Tree Shaking 优化：")]),a._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"76827"}},[t("code",{attrs:{"data-language":"java"}},[a._v("{\n  "),t("span",{staticClass:"hljs-string"},[a._v('"name"')]),a._v(": "),t("span",{staticClass:"hljs-string"},[a._v('"your-project"')]),a._v(",\n  "),t("span",{staticClass:"hljs-string"},[a._v('"sideEffects"')]),a._v(": "),t("span",{staticClass:"hljs-keyword"},[a._v("false")]),a._v("\n}\n")])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76828"}},[a._v("表示全部代码均无副作用，告知 webpack，它可以安全地删除未用到的 export 导出。")]),a._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"76829"}},[t("code",{attrs:{"data-language":"java"}},[a._v("{\n  "),t("span",{staticClass:"hljs-string"},[a._v('"name"')]),a._v(": "),t("span",{staticClass:"hljs-string"},[a._v('"your-project"')]),a._v(",\n  "),t("span",{staticClass:"hljs-string"},[a._v('"sideEffects"')]),a._v(": [\n    "),t("span",{staticClass:"hljs-string"},[a._v('"./src/some-side-effectful-file.js"')]),a._v("，\n    "),t("span",{staticClass:"hljs-string"},[a._v('"*.css"')]),a._v("\n  ]\n}\n")])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76830"}},[a._v("通过数组表示，"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77012"}},[a._v("./src/some-side-effectful-file.js")]),a._v("和所有"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77014"}},[a._v(".css")]),a._v("文件模块都有副作用。对于 Webpack 工具，"),t("strong",{attrs:{"data-nodeid":"77026"}},[a._v("开发者可以在")]),t("a",{attrs:{href:"https://github.com/webpack/webpack/issues/6065#issuecomment-351060570","data-nodeid":"77021"}},[a._v("module.rule")]),t("strong",{attrs:{"data-nodeid":"77027"}},[a._v("配置中声明副作用模块")]),a._v("。")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76831"}},[a._v("事实上，仅对上面"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77029"}},[a._v("add")]),a._v("函数，即便不通过声明 sideEffects，Webpack 也足够智能，能够分析出可 Tree Shaking 掉的部分，不过这需要我们对上述代码进行重构：")]),a._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"76832"}},[t("code",{attrs:{"data-language":"java"}},[t("span",{staticClass:"hljs-keyword"},[a._v("import")]),a._v(" { memoize } from "),t("span",{staticClass:"hljs-string"},[a._v("'./util'")]),a._v("\n"),t("span",{staticClass:"hljs-function"},[a._v("export function "),t("span",{staticClass:"hljs-title"},[a._v("add")]),t("span",{staticClass:"hljs-params"},[a._v("(a, b)")]),a._v(" ")]),a._v("{\n "),t("span",{staticClass:"hljs-keyword"},[a._v("return")]),a._v(" a + b\n}\nexport "),t("span",{staticClass:"hljs-keyword"},[a._v("const")]),a._v(" memoizedAdd = memoize(add)\n")])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76833"}},[a._v("此时 Webpack 的分析逻辑：")]),a._v(" "),t("ul",{attrs:{"data-nodeid":"76834"}},[t("li",{attrs:{"data-nodeid":"76835"}},[t("p",{attrs:{"data-nodeid":"76836"}},[t("code",{attrs:{"data-backticks":"1","data-nodeid":"77032"}},[a._v("memoize")]),a._v("函数是一个 ESM 模块，我们去"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77034"}},[a._v("util.js")]),a._v("中检查一下"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77036"}},[a._v("memoize")]),a._v("函数内容；")])]),a._v(" "),t("li",{attrs:{"data-nodeid":"76837"}},[t("p",{attrs:{"data-nodeid":"76838"}},[a._v("在"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77039"}},[a._v("util.js")]),a._v("中，发现"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77041"}},[a._v("memoize")]),a._v("函数是一个纯函数，因此如果"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77043"}},[a._v("add")]),a._v("函数没有被其他模块依赖，可以被安全 Tree Shaking 掉。")])])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76839"}},[a._v("所以，我们能得出一个 Tree Shaking 友好的最佳实践——在业务项目中，设置最小化副作用范围，同时通过合理的配置，给工程化工具最多的副作用信息。")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76840"}},[a._v("下面，我们再来看一个  Tree Shaking 友好的实践案例。")]),a._v(" "),t("h4",{attrs:{"data-nodeid":"76841"}},[a._v("一个 Tree Shaking 友好的导出模式")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76842"}},[a._v("参考以下代码：")]),a._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"76843"}},[t("code",{attrs:{"data-language":"java"}},[a._v("export "),t("span",{staticClass:"hljs-keyword"},[a._v("default")]),a._v(" {\n add(a, b) {\n  "),t("span",{staticClass:"hljs-keyword"},[a._v("return")]),a._v(" a + b\n }\n subtract(a, b) {\n  "),t("span",{staticClass:"hljs-keyword"},[a._v("return")]),a._v(" a - b\n }\n}\n")])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76844"}},[a._v("以及：")]),a._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"76845"}},[t("code",{attrs:{"data-language":"java"}},[a._v("export "),t("span",{staticClass:"hljs-class"},[t("span",{staticClass:"hljs-keyword"},[a._v("class")]),a._v(" "),t("span",{staticClass:"hljs-title"},[a._v("Number")]),a._v(" ")]),a._v("{\n constructor(num) {\n  "),t("span",{staticClass:"hljs-keyword"},[a._v("this")]),a._v(".num = num\n }\n add(otherNum) {\n  "),t("span",{staticClass:"hljs-keyword"},[a._v("return")]),a._v(" "),t("span",{staticClass:"hljs-keyword"},[a._v("this")]),a._v(".num + otherNum\n }\n subtract(otherNum) {\n  "),t("span",{staticClass:"hljs-keyword"},[a._v("return")]),a._v(" "),t("span",{staticClass:"hljs-keyword"},[a._v("this")]),a._v(".num - otherNum\n }\n}\n")])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76846"}},[a._v("对于上述情况，以 Webpack 为例，"),t("strong",{attrs:{"data-nodeid":"77055"}},[a._v("Webpack 将会趋向保留整个默认导出对象/class")]),a._v("（Webpack 和 Rollup 只处理函数和顶层的 import/export 变量，不能把没用到的类或对象内部的方法消除掉）。")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76847"}},[a._v("因此：")]),a._v(" "),t("ul",{attrs:{"data-nodeid":"76848"}},[t("li",{attrs:{"data-nodeid":"76849"}},[t("p",{attrs:{"data-nodeid":"76850"}},[a._v("导出一个包含多项属性和方法的对象")])]),a._v(" "),t("li",{attrs:{"data-nodeid":"76851"}},[t("p",{attrs:{"data-nodeid":"76852"}},[a._v("导出一个包含多项属性和方法的 class")])]),a._v(" "),t("li",{attrs:{"data-nodeid":"76853"}},[t("p",{attrs:{"data-nodeid":"76854"}},[a._v("使用"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77060"}},[a._v("export default")]),a._v("导出")])])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76855"}},[a._v("都不利于 Tree Shaking。即便现代化工程工具或 Webpack 支持对于对象或 class 的方法属性剪裁（比如 webpack-deep-scope-plugin 这个插件的设计，或 Webpack 和 Rollup 新版本的跟进），这些都产生了不必要的成本，增加了编译时负担。")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76856"}},[a._v("我们更加推荐的原则是："),t("strong",{attrs:{"data-nodeid":"77068"}},[a._v("原子化和颗粒化导出")]),a._v("。如下代码，就是一个更好的实践：")]),a._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"76857"}},[t("code",{attrs:{"data-language":"java"}},[t("span",{staticClass:"hljs-function"},[a._v("export function "),t("span",{staticClass:"hljs-title"},[a._v("add")]),t("span",{staticClass:"hljs-params"},[a._v("(a, b)")]),a._v(" ")]),a._v("{\n "),t("span",{staticClass:"hljs-keyword"},[a._v("return")]),a._v(" a + b\n}\n"),t("span",{staticClass:"hljs-function"},[a._v("export function "),t("span",{staticClass:"hljs-title"},[a._v("subtract")]),t("span",{staticClass:"hljs-params"},[a._v("(a, b)")]),a._v(" ")]),a._v("{\n "),t("span",{staticClass:"hljs-keyword"},[a._v("return")]),a._v(" a - b\n}\n")])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76858"}},[a._v("这种方式可以让 Webpack 更好地在编译时掌控和分析 Tree Shaking 信息，取得一个更优的 bundle size。")]),a._v(" "),t("h3",{attrs:{"data-nodeid":"76859"}},[a._v("前端工程生态和 Tree Shaking 实践")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76860"}},[a._v("通过上述内容，我们可以看出 Tree Shaking 依托于 ESM 静态分析的理论技术，而真正的 Tree Shaking 过程，还需要依靠前端工程工具实现。Tree Shaking 链路当然也就和前端工程生态绑定在一起，我们继续从工程生态层面，分析 Tree Shaking 实践。")]),a._v(" "),t("h4",{attrs:{"data-nodeid":"76861"}},[a._v("Babel 和 Tree Shaking")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76862"}},[a._v("Babel 已经成为现代化工程和基建方案的必备工具，但是考虑到 Tree Shaking，需要开发者注意："),t("strong",{attrs:{"data-nodeid":"77078"}},[a._v("如果使用 Babel 对代码进行编译，Babel 默认会将 ESM 编译为 CommonJS 模块规范")]),a._v("。而我们从前面理论知识知道，Tree Shaking 必须依托于 ESM。")]),a._v(" "),t("p",{attrs:{"data-nodeid":"80123"}},[a._v("为此，我们需要配置 Babel 对于模块化的编译降级，具体配置项在 "),t("a",{attrs:{href:"https://babeljs.io/docs/en/babel-preset-env#modules","data-nodeid":"80127"}},[a._v("babel-preset-env#modules")]),a._v(" 中可以找到。")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76864"}},[a._v("但既然是“前端工程生态”，那问题就没这么好解决。事实上，如果我们不使用 Babel 将代码编译为 CommonJS 规范的代码，某些工程链上的工具可能就要罢工了。比如 Jest，Jest 是基于 Node.js 开发的，运行在 Node.js 环境。因此使用 Jest 进行测试时，也就需要模块符合 CommonJS 规范，那么如何处理这种“模块死锁”呢？")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76865"}},[a._v("思路之一是"),t("strong",{attrs:{"data-nodeid":"77090"}},[a._v("根据不同的环境，采用不同的 Babel 配置")]),a._v("。在 production 编译环境中，我们配置：")]),a._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"76866"}},[t("code",{attrs:{"data-language":"java"}},[a._v("production: {\n   presets: [\n    [\n     "),t("span",{staticClass:"hljs-string"},[a._v("'@babel/preset-env'")]),a._v(",\n     {\n      modules: "),t("span",{staticClass:"hljs-keyword"},[a._v("false")]),a._v("\n     }\n    ]\n   ]\n  },\n}\n")])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76867"}},[a._v("在测试环境中：")]),a._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"76868"}},[t("code",{attrs:{"data-language":"java"}},[a._v("test: {\n   presets: [\n    [\n     '@babel/preset-env',\n     {\n      modules: 'commonjs\n     }\n    ]\n   ]\n  },\n}\n")])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76869"}},[a._v("但是在测试环境中，编译了业务代码为 CommonJS 规范并没有大功告成，我们还需要处理第三方模块代码。一些第三方模块代码为了方便进行 Tree Shaking，暴露出符合 ESM 模块的代码，对于这些模块，比如 Library1、Library2，我们还需要进行处理，这时候需要配置 Jest：")]),a._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"76870"}},[t("code",{attrs:{"data-language":"java"}},[t("span",{staticClass:"hljs-keyword"},[a._v("const")]),a._v(" path = require("),t("span",{staticClass:"hljs-string"},[a._v("'path'")]),a._v(")\n"),t("span",{staticClass:"hljs-keyword"},[a._v("const")]),a._v(" librariesToRecompile = [\n "),t("span",{staticClass:"hljs-string"},[a._v("'Library1'")]),a._v(",\n "),t("span",{staticClass:"hljs-string"},[a._v("'Library2'")]),a._v("\n].join("),t("span",{staticClass:"hljs-string"},[a._v("'|'")]),a._v(")\n"),t("span",{staticClass:"hljs-keyword"},[a._v("const")]),a._v(" config = {\n transformIgnorePatterns: [\n  `[\\\\/]node_modules[\\\\/](?!(${librariesToRecompile})).*$`\n ],\n transform: {\n  "),t("span",{staticClass:"hljs-string"},[a._v("'^.+\\.jsx?$'")]),a._v(": path.resolve(__dirname, "),t("span",{staticClass:"hljs-string"},[a._v("'transformer.js'")]),a._v(")\n }\n}\n")])]),a._v(" "),t("p",{attrs:{"data-nodeid":"84905"}},[t("code",{attrs:{"data-backticks":"1","data-nodeid":"84906"}},[a._v("transformIgnorePatterns")]),a._v("是 Jest 的一个配置项，默认值为"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"84908"}},[a._v("node_modules")]),a._v("，它表示："),t("code",{attrs:{"data-backticks":"1","data-nodeid":"84910"}},[a._v("node_modules")]),a._v("中的第三方模块代码，都不需要经过"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"84912"}},[a._v("babel-jest")]),a._v("编译。因此，"),t("strong",{attrs:{"data-nodeid":"84920"}},[a._v("我们自定义 "),t("code",{attrs:{"data-backticks":"1","data-nodeid":"84916"}},[a._v("transformIgnorePatterns")]),a._v("的值为一个包含了 Library1、Library2 的正则表达式即可")]),a._v("。")]),a._v(" "),t("h4",{attrs:{"data-nodeid":"76872"}},[a._v("Webpack 和 Tree Shaking")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76873"}},[a._v("上面我们已经讲解了很多关于 Webpack 处理 Tree Shaking 的内容了，这里我们进一步补充。事实上，"),t("strong",{attrs:{"data-nodeid":"77117"}},[a._v("Webpack4.0 以上版本在 mode 为 production 时，会自动开启 Tree Shaking 能力")]),a._v("。默认 production mode 的配置如下：")]),a._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"76874"}},[t("code",{attrs:{"data-language":"java"}},[t("span",{staticClass:"hljs-keyword"},[a._v("const")]),a._v(" config = {\n mode: "),t("span",{staticClass:"hljs-string"},[a._v("'production'")]),a._v(",\n optimization: {\n  usedExports: "),t("span",{staticClass:"hljs-keyword"},[a._v("true")]),a._v(",\n  minimizer: [\n   "),t("span",{staticClass:"hljs-keyword"},[a._v("new")]),a._v(" TerserPlugin({...}) "),t("span",{staticClass:"hljs-comment"},[a._v("// 支持删除死代码的压缩器")]),a._v("\n  ]\n }\n}\n")])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76875"}},[a._v("其实，Webpack 真正执行模块去除，是依赖了 TerserPlugin、UglifyJS 等压缩插件。"),t("strong",{attrs:{"data-nodeid":"77123"}},[a._v("Webpack 负责对模块进行分析和标记，而这些压缩插件负责根据标记结果，进行代码删除")]),a._v("。Webpack 在分析时，有三类相关的标记：")]),a._v(" "),t("ul",{attrs:{"data-nodeid":"76876"}},[t("li",{attrs:{"data-nodeid":"76877"}},[t("p",{attrs:{"data-nodeid":"76878"}},[a._v("harmony export，被使用过的 export 会被标记为 harmony export；")])]),a._v(" "),t("li",{attrs:{"data-nodeid":"76879"}},[t("p",{attrs:{"data-nodeid":"76880"}},[a._v("unused harmony export，没被使用过的 export 标记为 unused harmony export；")])]),a._v(" "),t("li",{attrs:{"data-nodeid":"76881"}},[t("p",{attrs:{"data-nodeid":"76882"}},[a._v("harmony import，所有 import 标记为 harmony import。")])])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76883"}},[a._v("上述标记实现的 Webpack 源码在"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77128"}},[a._v("lib/dependencies/")]),a._v("文件中，这里不再进行源码解读了。具体过程主要是：")]),a._v(" "),t("ul",{attrs:{"data-nodeid":"76884"}},[t("li",{attrs:{"data-nodeid":"76885"}},[t("p",{attrs:{"data-nodeid":"76886"}},[a._v("Webpack 在编译分析阶段，将每一个模块放入 ModuleGraph 中维护；")])]),a._v(" "),t("li",{attrs:{"data-nodeid":"76887"}},[t("p",{attrs:{"data-nodeid":"76888"}},[a._v("依靠 HarmonyExportSpecifierDependency 和 HarmonyImportSpecifierDependency 分别识别和处理 import 以及 export；")])]),a._v(" "),t("li",{attrs:{"data-nodeid":"76889"}},[t("p",{attrs:{"data-nodeid":"76890"}},[a._v("依靠 HarmonyExportSpecifierDependency 识别 used export 和 unused export。")])])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76891"}},[a._v("至此，我们理解了使用 Webpack 进行 Tree Shaking 的原理。接下来，我们再看看著名的公共库都是如何处理 Tree Shaking 的。")]),a._v(" "),t("h4",{attrs:{"data-nodeid":"76892"}},[a._v("Vue 和 Tree Shaking")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76893"}},[a._v("在 Vue 2.0 版本中，Vue 对象会存在一些全局 API，比如：")]),a._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"76894"}},[t("code",{attrs:{"data-language":"java"}},[t("span",{staticClass:"hljs-keyword"},[a._v("import")]),a._v(" Vue from "),t("span",{staticClass:"hljs-string"},[a._v("'vue'")]),a._v("\nVue.nextTick(() => {\n  "),t("span",{staticClass:"hljs-comment"},[a._v("//...")]),a._v("\n})\n")])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76895"}},[a._v("如果我们没有使用"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77137"}},[a._v("Vue.nextTick")]),a._v("方法，那么"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77139"}},[a._v("nextTick")]),a._v("这样的全局 API 就成了 dead code，且不容易被 Tree Shaking 掉。为此，在 Vue 3 中，Vue 团队考虑了 Tree Shaking 兼容，进行了重构，"),t("strong",{attrs:{"data-nodeid":"77145"}},[a._v("全局 API 需要通过原生 ES Module 的引用方式进行具名引用")]),a._v("，对应前面的代码，需要：")]),a._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"76896"}},[t("code",{attrs:{"data-language":"java"}},[t("span",{staticClass:"hljs-keyword"},[a._v("import")]),a._v(" { nextTick } from "),t("span",{staticClass:"hljs-string"},[a._v("'vue'")]),a._v("\nnextTick(() => {\n  "),t("span",{staticClass:"hljs-comment"},[a._v("//...")]),a._v("\n})\n")])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76897"}},[a._v("除了这些全局 API ，Vue 3.0 也实现了很多内置的组件以及工具的具名导出。这些都是前端生态中，公共库拥抱 Tree Shaking 的表现。")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76898"}},[a._v("此外，我们也可以灵活使用 build-time flags 来帮助构建工具实现 Tree Shaking。以 Webpack"),t("a",{attrs:{href:"https://webpack.js.org/plugins/define-plugin/","data-nodeid":"77150"}},[a._v("DefinePlugin ")]),a._v("为例，下面代码：")]),a._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"76899"}},[t("code",{attrs:{"data-language":"java"}},[t("span",{staticClass:"hljs-keyword"},[a._v("import")]),a._v(" { validateoptions } from "),t("span",{staticClass:"hljs-string"},[a._v("'./validation'")]),a._v("\n"),t("span",{staticClass:"hljs-function"},[a._v("function "),t("span",{staticClass:"hljs-title"},[a._v("init")]),t("span",{staticClass:"hljs-params"},[a._v("(options)")]),a._v(" ")]),a._v("{\n "),t("span",{staticClass:"hljs-keyword"},[a._v("if")]),a._v(" (!__PRODUCTION__) {\n  validateoptions(options)\n }\n}\n")])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76900"}},[a._v("通过"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77153"}},[a._v("__PRODUCTION__")]),a._v("变量，在 production 环境下，我们可以将"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77155"}},[a._v("validateoptions")]),a._v("函数进行删除。")]),a._v(" "),t("h4",{attrs:{"data-nodeid":"76901"}},[a._v("如何设计一个兼顾 Tree Shaking 和易用性的公共库")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76902"}},[a._v("上面我们分析了 Vue 拥抱 Tree Shaking 的例子，下面我们应该从另一个更宏观的角度看待这个问题。作为一个公共库的设计者，我们应该如何兼顾 Tree Shaking 和易用性的公共库呢？")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76903"}},[a._v("试想，如果我们以 ESM 的方式对外暴露代码，那么就很难直接兼容 CommonJS 规范，也就是说"),t("strong",{attrs:{"data-nodeid":"77168"}},[a._v("在 Node.js 环境中，使用者如果直接以 require 方式引用的话，就会得到报错")]),a._v("。"),t("strong",{attrs:{"data-nodeid":"77169"}},[a._v("如果以 CommonJS 规范对外暴露代码，又不利于 Tree Shaking")]),a._v("。")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76904"}},[a._v("因此，如果想要一个 npm 包既能向外提供 ESM 规范的代码，又能向外提供 CommonJS 规范的代码，我们就只能通过“协约”来定义清楚。实际上，npm"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77171"}},[a._v("package.json")]),a._v("以及社区工程化规范，解决了这个问题：")]),a._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"76905"}},[t("code",{attrs:{"data-language":"java"}},[a._v("{\n  "),t("span",{staticClass:"hljs-string"},[a._v('"name"')]),a._v(": "),t("span",{staticClass:"hljs-string"},[a._v('"Library"')]),a._v(",\n  "),t("span",{staticClass:"hljs-string"},[a._v('"main"')]),a._v(": "),t("span",{staticClass:"hljs-string"},[a._v('"dist/index.cjs.js"')]),a._v(",\n  "),t("span",{staticClass:"hljs-string"},[a._v('"module"')]),a._v(": "),t("span",{staticClass:"hljs-string"},[a._v('"dist/index.esm.js"')]),a._v(",\n}\n")])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76906"}},[a._v("其实，标准 package.json 语法中，只有一个入口"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77174"}},[a._v("main")]),a._v("。作为公共库设计者，我们通过"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77176"}},[a._v("main")]),a._v("来暴露 CommonJS 规范打包的代码"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77178"}},[a._v("dist/index.cjs.js")]),a._v("；在 Webpack 等构建工具中，又支持了"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77180"}},[a._v("module")]),a._v("——这个新的入口字段。因此，"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77182"}},[a._v("module")]),a._v("并非 package.json 的标准字段，而是打包工具专用的字段，用来指定符合 ESM 标准的入口文件。")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76907"}},[a._v("这样一来，当"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77185"}},[a._v("require('Library')")]),a._v("时，Webpack 会找到："),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77187"}},[a._v("dist/index.cjs.js")]),a._v("；当"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77189"}},[a._v("import Library from 'Library'")]),a._v("时，Webpack 会找到："),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77191"}},[a._v("dist/index.esm.js")]),a._v("。")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76908"}},[a._v("这里我们不妨举一个著名的公共库例子，那就是 Lodash。Lodash 其实并不支持 Tree Shaking，其"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77194"}},[a._v("package.json")]),a._v("：")]),a._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"76909"}},[t("code",{attrs:{"data-language":"java"}},[a._v("{\n  "),t("span",{staticClass:"hljs-string"},[a._v('"name"')]),a._v(": "),t("span",{staticClass:"hljs-string"},[a._v('"lodash"')]),a._v(",\n  "),t("span",{staticClass:"hljs-string"},[a._v('"version"')]),a._v(": "),t("span",{staticClass:"hljs-string"},[a._v('"5.0.0"')]),a._v(",\n  "),t("span",{staticClass:"hljs-string"},[a._v('"license"')]),a._v(": "),t("span",{staticClass:"hljs-string"},[a._v('"MIT"')]),a._v(",\n  "),t("span",{staticClass:"hljs-string"},[a._v('"private"')]),a._v(": "),t("span",{staticClass:"hljs-keyword"},[a._v("true")]),a._v(",\n  "),t("span",{staticClass:"hljs-string"},[a._v('"main"')]),a._v(": "),t("span",{staticClass:"hljs-string"},[a._v('"lodash.js"')]),a._v(",\n  "),t("span",{staticClass:"hljs-string"},[a._v('"engines"')]),a._v(": {\n    "),t("span",{staticClass:"hljs-string"},[a._v('"node"')]),a._v(": "),t("span",{staticClass:"hljs-string"},[a._v('">=4.0.0"')]),a._v("\n  },\n  "),t("span",{staticClass:"hljs-comment"},[a._v("//...")]),a._v("\n}\n")])]),a._v(" "),t("p",{attrs:{"data-nodeid":"85861"}},[a._v("只有一个"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"85863"}},[a._v("main")]),a._v("入口，且"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"85865"}},[a._v("lodash.js")]),a._v("是 UMD 形式的代码，不利于做到 Tree Shaking。为了支持 Tree shakibng，lodash 打包出来专门的 "),t("a",{attrs:{href:"https://www.npmjs.com/package/lodash-es","data-nodeid":"85869"}},[a._v("lodash-es")]),a._v("，其"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"85871"}},[a._v("package.json")]),a._v("：")]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token string-property property"}},[a._v('"main"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"lodash.js"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token string-property property"}},[a._v('"module"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"lodash.js"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token string-property property"}},[a._v('"name"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"lodash-es"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token string-property property"}},[a._v('"sideEffects"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("false")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//...")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",{attrs:{"data-nodeid":"76912"}},[a._v("由上述代码可知，lodash-es"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77208"}},[a._v("main")]),a._v("、"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77210"}},[a._v("module")]),a._v("、"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77212"}},[a._v("sideEffects")]),a._v("三字段齐全，通过 ESM 导出，天然支持了 Tree Shaking。")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76913"}},[a._v("总之，万变不离其宗，只要我们掌握了 Tree Shaking 的原理，那么在涉及公共库时，就能做到游刃有余，以各种形式支持到 Tree Shaking。当然，普遍做法是在第三方库打包构建时，参考 antd，一般都会构建出 lib/ 和 es/ 两个文件夹，并配置"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77215"}},[a._v("package.json")]),a._v("的"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77217"}},[a._v("main")]),a._v("、"),t("code",{attrs:{"data-backticks":"1","data-nodeid":"77219"}},[a._v("module")]),a._v("字段即可。")]),a._v(" "),t("h4",{attrs:{"data-nodeid":"76914"}},[a._v("CSS 和 Tree Shaking")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76915"}},[a._v("以上内容都是针对 JavaScript 代码的 Tree Shaking，作为前端工程师，我们当然也要考虑对 CSS 文件做 Tree Shaking。")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76916"}},[a._v("实现思路也很简单，"),t("strong",{attrs:{"data-nodeid":"77228"}},[a._v("CSS 的 Tree Shaking 要在样式表中，找出没有被应用到选择器样式，进行删除")]),a._v("。那么我们只需要：")]),a._v(" "),t("ul",{attrs:{"data-nodeid":"76917"}},[t("li",{attrs:{"data-nodeid":"76918"}},[t("p",{attrs:{"data-nodeid":"76919"}},[a._v("遍历所有 CSS 文件的选择器；")])]),a._v(" "),t("li",{attrs:{"data-nodeid":"76920"}},[t("p",{attrs:{"data-nodeid":"76921"}},[a._v("根据所有 CSS 文件的选择器，在 JavaScript 代码中进行选择器匹配；")])]),a._v(" "),t("li",{attrs:{"data-nodeid":"76922"}},[t("p",{attrs:{"data-nodeid":"76923"}},[a._v("如果没有匹配到，则删除对应选择器的样式代码。")])])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76924"}},[a._v("如何遍历所有 CSS 文件的选择器呢？Babel 依靠 AST 技术，完成了对 JavaScript 代码的遍历分析，而在样式世界中，PostCSS 就起到了 Babel 的作用。PostCSS 提供了一个解析器，它能够将 CSS 解析成 AST 抽象语法树，"),t("strong",{attrs:{"data-nodeid":"77237"}},[a._v("我们可以通过 PostCSS 插件对 CSS 对应的 AST 进行操作，达到 Tree Shaking 的目的")]),a._v("。")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76925"}},[a._v("PostCSS 原理如下图：")]),a._v(" "),t("p",{attrs:{"data-nodeid":"88219"}},[t("img",{attrs:{src:"https://s0.lgstatic.com/i/image2/M01/05/E0/Cip5yGABPraACuJCAAGHB98AwXg855.png",alt:"Drawing 0.png","data-nodeid":"88222"}}),t("br"),a._v(" "),t("img",{attrs:{src:"https://s0.lgstatic.com/i/image/M00/8D/F3/Ciqc1GABPsGAfsSVAAGgxx7GqrU331.png",alt:"Drawing 1.png","data-nodeid":"88226"}})]),a._v(" "),t("div",{attrs:{"data-nodeid":"89167"}},[t("p",{staticStyle:{"text-align":"center"}},[a._v("PostCSS 原理图")])]),a._v(" "),t("p",{attrs:{"data-nodeid":"90106"}},[a._v("这里给大家推荐 "),t("a",{attrs:{href:"https://github.com/FullHuman/purgecss/tree/master/packages/purgecss-webpack-plugin","data-nodeid":"90110"}},[a._v("purgecss-webpack-plugin")]),a._v("，其原理也很简单：")]),a._v(" "),t("ul",{attrs:{"data-nodeid":"76930"}},[t("li",{attrs:{"data-nodeid":"76931"}},[t("p",{attrs:{"data-nodeid":"76932"}},[a._v("监听 Webpack compilation 完成阶段，从 compilation 中找到所有的 CSS 文件（对应源码）：")])])]),a._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("export")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("default")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("PurgeCSSPlugin")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token literal-property property"}},[a._v("options")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" UserDefinedOptions"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token literal-property property"}},[a._v("purgedStats")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" PurgedStats "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("constructor")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[t("span",{pre:!0,attrs:{class:"token literal-property property"}},[a._v("options")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" UserDefinedOptions")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("options "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" options"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("apply")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("compiler"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" Compiler"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    compiler"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("hooks"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("compilation"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("tap")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("\n      pluginName"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n      "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("initializePlugin")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("bind")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n  \n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//...")]),a._v("\n  \n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("ul",{attrs:{"data-nodeid":"76934"}},[t("li",{attrs:{"data-nodeid":"76935"}},[t("p",{attrs:{"data-nodeid":"76936"}},[a._v("将所有的 CSS 文件交给 PostCss 处理（"),t("a",{attrs:{href:"https://github.com/FullHuman/purgecss/blob/84da7ca98872bae29317f88c4295b400a6c02d06/packages/purgecss/src/index.ts#L274","data-nodeid":"77255"}},[a._v("源码")]),a._v("关键部分，对 CSS AST 应用规则）：")])])]),a._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"76937"}},[t("code",{attrs:{"data-language":"java"}},[t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[a._v("public")]),a._v(" "),t("span",{staticClass:"hljs-title"},[a._v("walkThroughCSS")]),t("span",{staticClass:"hljs-params"},[a._v("(\n    root: postcss.Root,\n    selectors: ExtractorResultSets\n  )")]),a._v(": "),t("span",{staticClass:"hljs-keyword"},[a._v("void")]),a._v(" ")]),a._v("{\n    root.walk((node) => {\n      "),t("span",{staticClass:"hljs-keyword"},[a._v("if")]),a._v(" (node.type === "),t("span",{staticClass:"hljs-string"},[a._v('"rule"')]),a._v(") {\n        "),t("span",{staticClass:"hljs-keyword"},[a._v("return")]),a._v(" "),t("span",{staticClass:"hljs-keyword"},[a._v("this")]),a._v(".evaluateRule(node, selectors);\n      }\n      "),t("span",{staticClass:"hljs-keyword"},[a._v("if")]),a._v(" (node.type === "),t("span",{staticClass:"hljs-string"},[a._v('"atrule"')]),a._v(") {\n        "),t("span",{staticClass:"hljs-keyword"},[a._v("return")]),a._v(" "),t("span",{staticClass:"hljs-keyword"},[a._v("this")]),a._v(".evaluateAtRule(node);\n      }\n      "),t("span",{staticClass:"hljs-keyword"},[a._v("if")]),a._v(" (node.type === "),t("span",{staticClass:"hljs-string"},[a._v('"comment"')]),a._v(") {\n        "),t("span",{staticClass:"hljs-keyword"},[a._v("if")]),a._v(" (isIgnoreAnnotation(node, "),t("span",{staticClass:"hljs-string"},[a._v('"start"')]),a._v(")) {\n          "),t("span",{staticClass:"hljs-keyword"},[a._v("this")]),a._v(".ignore = "),t("span",{staticClass:"hljs-keyword"},[a._v("true")]),a._v(";\n          "),t("span",{staticClass:"hljs-comment"},[a._v("// remove ignore annotation")]),a._v("\n          node.remove();\n        } "),t("span",{staticClass:"hljs-keyword"},[a._v("else")]),a._v(" "),t("span",{staticClass:"hljs-keyword"},[a._v("if")]),a._v(" (isIgnoreAnnotation(node, "),t("span",{staticClass:"hljs-string"},[a._v('"end"')]),a._v(")) {\n          "),t("span",{staticClass:"hljs-keyword"},[a._v("this")]),a._v(".ignore = "),t("span",{staticClass:"hljs-keyword"},[a._v("false")]),a._v(";\n          "),t("span",{staticClass:"hljs-comment"},[a._v("// remove ignore annotation")]),a._v("\n          node.remove();\n        }\n      }\n    });\n  }\n")])]),a._v(" "),t("ul",{attrs:{"data-nodeid":"76938"}},[t("li",{attrs:{"data-nodeid":"76939"}},[t("p",{attrs:{"data-nodeid":"76940"}},[a._v("利用 PostCss 插件能力，基于 AST 技术，找出无用代码并进行删除。")])])]),a._v(" "),t("p",{attrs:{"data-nodeid":"76941"}},[a._v("核心删除未使用 CSS 代码的逻辑在"),t("a",{attrs:{href:"https://github.com/FullHuman/purgecss/blob/84da7ca98872bae29317f88c4295b400a6c02d06/packages/purgecss/src/index.ts#L617","data-nodeid":"77262"}},[t("code",{attrs:{"data-backticks":"1","data-nodeid":"77260"}},[a._v("purge")]),a._v(" 方法中")]),a._v("，这里我们不再展开。")]),a._v(" "),t("h3",{attrs:{"data-nodeid":"76942"}},[a._v("总结")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76943"}},[a._v("本小节，我们分析了 Tree Shaking 相关知识，我们发现这一理论内容还需要配合构建工具完成落地，而这一系列过程不只是想象中那样简单。")]),a._v(" "),t("p",{staticClass:"te-preview-highlight",attrs:{"data-nodeid":"91050"}},[t("img",{attrs:{src:"https://s0.lgstatic.com/i/image/M00/8D/F3/Ciqc1GABPt6AAFyMAAGLjLOlwJM945.png",alt:"Drawing 2.png","data-nodeid":"91053"}})]),a._v(" "),t("p",{attrs:{"data-nodeid":"76945"}},[a._v("这里我想给你留一个思考题，Rollup 是如何实现 Tree Shaking 的呢？欢迎在留言区和我分享你的观点。")]),a._v(" "),t("p",{attrs:{"data-nodeid":"76946"}},[a._v("更多内容，我们会结合下一讲“如何理解 AST 实现和编译原理？”，带你实现一个真实的 AST 的落地场景，完成一个简易版 Tree Shaking 实现。我们下一讲再见！")]),a._v(" "),t("hr"),a._v(" "),t("h3",{attrs:{id:"精选评论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#精选评论"}},[a._v("#")]),a._v(" 精选评论")]),a._v(" "),t("h5",{attrs:{id:"铭"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#铭"}},[a._v("#")]),a._v(" **铭")]),a._v(" "),t("blockquote",[t("p",[a._v("写的很好")])]),a._v(" "),t("h5",{attrs:{id:"_7269"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7269"}},[a._v("#")]),a._v(" **7269")]),a._v(" "),t("blockquote",[t("p",[a._v("那个裁剪css的插件，我们业务中很多动态class，貌似只能配置白名单了")])]),a._v(" "),t("h5",{attrs:{id:"萱"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#萱"}},[a._v("#")]),a._v(" *萱")]),a._v(" "),t("blockquote",[t("p",[a._v("有些html中的css类是js动态生成的，那岂不是把一些css给摇树掉了？")])]),a._v(" "),t("h6",{attrs:{id:"讲师回复"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#讲师回复"}},[a._v("#")]),a._v("     讲师回复")]),a._v(" "),t("blockquote",[t("p",[a._v("    不会，会根据 js 进行分析")])]),a._v(" "),t("h5",{attrs:{id:"_3336"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3336"}},[a._v("#")]),a._v(" **3336")]),a._v(" "),t("blockquote",[t("p",[a._v("是不是UMD模块代码做不到TreeShaking？")])]),a._v(" "),t("h6",{attrs:{id:"讲师回复-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#讲师回复-2"}},[a._v("#")]),a._v("     讲师回复")]),a._v(" "),t("blockquote",[t("p",[a._v("    是")])]),a._v(" "),t("h5",{attrs:{id:"威"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#威"}},[a._v("#")]),a._v(" *威")]),a._v(" "),t("blockquote",[t("p",[a._v("import现在不一定在最顶层鸭")])]),a._v(" "),t("h6",{attrs:{id:"讲师回复-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#讲师回复-3"}},[a._v("#")]),a._v("     讲师回复")]),a._v(" "),t("blockquote",[t("p",[a._v("    static import vs dynamic import")])]),a._v(" "),t("h5",{attrs:{id:"平"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#平"}},[a._v("#")]),a._v(" **平")]),a._v(" "),t("blockquote",[t("p",[a._v("问一下，如果项目里有一个包不支持 Tree Shaking，那打包时整个项目时，除了这个不支持的包以为，其他包都是用Tree Shaking打包吗？")])]),a._v(" "),t("h6",{attrs:{id:"讲师回复-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#讲师回复-4"}},[a._v("#")]),a._v("     讲师回复")]),a._v(" "),t("blockquote",[t("p",[a._v("    是，但得看你配置和实现")])])])}),[],!1,null,null,null);t.default=n.exports}}]);