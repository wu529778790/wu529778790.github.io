(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{456:function(e,n,t){"use strict";t.r(n);var a=t(4),s=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"webpack-异步加载原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#webpack-异步加载原理"}},[e._v("#")]),e._v(" webpack 异步加载原理")]),e._v(" "),n("p",[n("code",[e._v("webpack ensure")]),e._v(" 有人称它为异步加载，也有人称为代码切割，他其实就是将 js 模块给独立导出一个.js 文件，然后使用这个模块的时候，再创建一个 "),n("code",[e._v("script")]),e._v(" 对象，加入到 "),n("code",[e._v("document.head")]),e._v(" 对象中，浏览器会自动帮我们发起请求，去请求这个 js 文件，然后写个回调函数，让请求到的 js 文件做一些业务操作。")]),e._v(" "),n("h3",{attrs:{id:"举个例子"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#举个例子"}},[e._v("#")]),e._v(" 举个例子")]),e._v(" "),n("p",[e._v("需求："),n("code",[e._v("main.js")]),e._v(" 依赖两个 js 文件："),n("code",[e._v("A.js")]),e._v(" 是点击 aBtn 按钮后，才执行的逻辑，"),n("code",[e._v("B.js")]),e._v(" 是点击 bBtn 按钮后，才执行的逻辑。")]),e._v(" "),n("p",[n("code",[e._v("webpack.config.js")]),e._v("，我们先来写一下 "),n("code",[e._v("webpack")]),e._v(" 打包的配置的代码")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const path = require('path') // 路径处理模块\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin') // 引入CleanWebpackPlugin插件\n\nmodule.exports = {\n  entry: {\n    index: path.join(__dirname, '/src/main.js'),\n  },\n  output: {\n    path: path.join(__dirname, '/dist'),\n    filename: 'index.js',\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.join(__dirname, '/index.html'),\n    }),\n    new CleanWebpackPlugin(), // 所要清理的文件夹名称\n  ],\n}\n")])])]),n("p",[n("code",[e._v("index.html")]),e._v(" 代码如下")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>webpack</title>\n  </head>\n  <body>\n    <div id="app">\n      <button id="aBtn">按钮A</button>\n      <button id="bBtn">按钮B</button>\n    </div>\n  </body>\n</html>\n')])])]),n("p",[e._v("入口文件 "),n("code",[e._v("main.js")]),e._v(" 如下")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import A from './A'\nimport B from './B'\n\ndocument.getElementById('aBtn').onclick = function () {\n  alert(A)\n}\n\ndocument.getElementById('bBtn').onclick = function () {\n  alert(B)\n}\n")])])]),n("p",[n("code",[e._v("A.js")]),e._v(" 和 "),n("code",[e._v("B.js")]),e._v(" 的代码分别如下")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// A.js\nconst A = 'hello A'\nmodule.exports = A\n\n// B.js\nconst B = 'hello B'\nmodule.exports = B\n")])])]),n("p",[e._v("此时，我们对项目进行 "),n("code",[e._v("npm run build")]),e._v("， 打包出来的只有两个文件")]),e._v(" "),n("ul",[n("li",[e._v("index.html")]),e._v(" "),n("li",[e._v("index.js")])]),e._v(" "),n("p",[e._v("由此可见，此时 "),n("code",[e._v("webpack")]),e._v(" 把 "),n("code",[e._v("main.js")]),e._v(" 依赖的两个文件都同时打包到同一个 js 文件，并在 index.html 中引入。但是 "),n("code",[e._v("A.js")]),e._v(" 和 "),n("code",[e._v("B.js")]),e._v(" 都是点击相应按钮才会执行的逻辑，如果用户并没有点击相应按钮，而且这两个文件又是比较大的话，这样是不是就导致首页默认加载的 js 文件太大，从而导致首页渲染较慢呢？那么有能否实现当用户点击按钮的时候再加载相应的依赖文件呢？")]),e._v(" "),n("p",[n("code",[e._v("webpack.ensure")]),e._v(" 就解决了这个问题。")]),e._v(" "),n("h3",{attrs:{id:"require-ensure-异步加载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#require-ensure-异步加载"}},[e._v("#")]),e._v(" require.ensure 异步加载")]),e._v(" "),n("p",[e._v("下面我们将 "),n("code",[e._v("main.js")]),e._v(" 改成异步加载的方式")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("document.getElementById('aBtn').onclick = function () {\n  //异步加载A\n  require.ensure([], function () {\n    let A = require('./A.js')\n    alert(A)\n  })\n}\n\ndocument.getElementById('bBtn').onclick = function () {\n  //异步加载b\n  require.ensure([], function () {\n    let B = require('./B.js')\n    alert(B)\n  })\n}\n")])])]),n("p",[e._v("此时，我们再进行一下打包，发现多了 "),n("code",[e._v("1.index.js")]),e._v(" 和 "),n("code",[e._v("2.index.js")]),e._v(" 两个文件。而我们打开页面时只引入了 "),n("code",[e._v("index.js")]),e._v(" 一个文件，当点击按钮 A 的时候才引入 "),n("code",[e._v("1.index.js")]),e._v(" 文件，点击按钮 B 的时候才引入 "),n("code",[e._v("2.index.js")]),e._v(" 文件。这样就满足了我们按需加载的需求。")]),e._v(" "),n("p",[n("code",[e._v("require.ensure")]),e._v(" 这个函数是一个代码分离的分割线，表示回调里面的 "),n("code",[e._v("require")]),e._v(" 是我们想要进行分割出去的，即 "),n("code",[e._v("require('./A.js')")]),e._v("，把 A.js 分割出去，形成一个 "),n("code",[e._v("webpack")]),e._v(" 打包的单独 js 文件。它的语法如下")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("require.ensure(dependencies: String[], callback: function(require), chunkName: String)\n")])])]),n("p",[e._v("我们打开 "),n("code",[e._v("1.index.js")]),e._v(" 文件，发现它的代码如下")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(";(window.webpackJsonp = window.webpackJsonp || []).push([\n  [1],\n  [\n    ,\n    function (o, n) {\n      o.exports = 'hello A'\n    },\n  ],\n])\n")])])]),n("p",[e._v("由上面的代码可以看出：")]),e._v(" "),n("ol",[n("li",[e._v("异步加载的代码，会保存在一个全局的 "),n("code",[e._v("webpackJsonp")]),e._v(" 中。")]),e._v(" "),n("li",[n("code",[e._v("webpackJsonp.push")]),e._v(" 的的值，两个参数分别为异步加载的文件中存放的需要安装的模块对应的 id 和异步加载的文件中存放的需要安装的模块列表。")]),e._v(" "),n("li",[e._v("在满足某种情况下，会执行具体模块中的代码。")])]),e._v(" "),n("h3",{attrs:{id:"import-按需加载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#import-按需加载"}},[e._v("#")]),e._v(" import() 按需加载")]),e._v(" "),n("p",[e._v("webpack4 官方文档提供了模块按需切割加载，配合 es6 的按需加载 "),n("code",[e._v("import()")]),e._v(" 方法，可以做到减少首页包体积，加快首页的请求速度，只有其他模块，只有当需要的时候才会加载对应 js。")]),e._v(" "),n("p",[n("code",[e._v("import()")]),e._v("的语法十分简单。该函数只接受一个参数，就是引用包的地址，并且使用了 "),n("code",[e._v("promise")]),e._v(" 式的回调，获取加载的包。在代码中所有被 "),n("code",[e._v("import()")]),e._v("的模块，都将打成一个单独的包，放在 "),n("code",[e._v("chunk")]),e._v(" 存储的目录下。在浏览器运行到这一行代码时，就会自动请求这个资源，实现异步加载。")]),e._v(" "),n("p",[e._v("下面我们将上述代码改成 "),n("code",[e._v("import()")]),e._v("方式。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("document.getElementById('aBtn').onclick = function () {\n  //异步加载A\n  import('./A').then((data) => {\n    alert(data.A)\n  })\n}\n\ndocument.getElementById('bBtn').onclick = function () {\n  //异步加载b\n  import('./B').then((data) => {\n    alert(data.B)\n  })\n}\n")])])]),n("p",[e._v("此时打包出来的文件和 "),n("code",[e._v("webpack.ensure")]),e._v(" 方法是一样的。")]),e._v(" "),n("h2",{attrs:{id:"路由懒加载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#路由懒加载"}},[e._v("#")]),e._v(" 路由懒加载")]),e._v(" "),n("p",[e._v("为什么需要懒加载？")]),e._v(" "),n("p",[e._v("像 vue 这种单页面应用，如果没有路由懒加载，运用 webpack 打包后的文件将会很大，造成进入首页时，需要加载的内容过多，出现较长时间的白屏，运用路由懒加载则可以将页面进行划分，需要的时候才加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时。")]),e._v(" "),n("p",[e._v("vue 路由懒加载有以下三种方式")]),e._v(" "),n("ul",[n("li",[e._v("vue 异步组件")]),e._v(" "),n("li",[e._v("ES6 的 "),n("code",[e._v("import()")])]),e._v(" "),n("li",[e._v("webpack 的 "),n("code",[e._v("require.ensure()")])])]),e._v(" "),n("h3",{attrs:{id:"vue-异步组件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue-异步组件"}},[e._v("#")]),e._v(" vue 异步组件")]),e._v(" "),n("p",[e._v("这种方法主要是使用了 "),n("code",[e._v("resolve")]),e._v(" 的异步机制，用 "),n("code",[e._v("require")]),e._v(" 代替了 "),n("code",[e._v("import")]),e._v(" 实现按需加载")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export default new Router({\n  routes: [\n    {\n      path: '/home',',\n      component: (resolve) => require(['@/components/home'], resolve),\n    },\n    {\n      path: '/about',',\n      component: (resolve) => require(['@/components/about'], resolve),\n    },\n  ],\n})\n")])])]),n("h3",{attrs:{id:"require-ensure"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#require-ensure"}},[e._v("#")]),e._v(" require.ensure")]),e._v(" "),n("p",[e._v("这种模式可以通过参数中的 "),n("code",[e._v("webpackChunkName")]),e._v(" 将 js 分开打包。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export default new Router({\n  routes: [\n    {\n      path: '/home',\n      component: (resolve) => require.ensure([], () => resolve(require('@/components/home')), 'home'),\n    },\n    {\n      path: '/about',\n      component: (resolve) => require.ensure([], () => resolve(require('@/components/about')), 'about'),\n    },\n  ],\n})\n")])])]),n("h3",{attrs:{id:"es6-的-import"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#es6-的-import"}},[e._v("#")]),e._v(" ES6 的 import()")]),e._v(" "),n("p",[n("code",[e._v("vue-router")]),e._v(" 在官网提供了一种方法，可以理解也是为通过 "),n("code",[e._v("Promise")]),e._v(" 的 "),n("code",[e._v("resolve")]),e._v(" 机制。因为 "),n("code",[e._v("Promise")]),e._v(" 函数返回的 "),n("code",[e._v("Promise")]),e._v(" 为 "),n("code",[e._v("resolve")]),e._v(" 组件本身，而我们又可以使用 "),n("code",[e._v("import")]),e._v(" 来导入组件。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export default new Router({\n  routes: [\n    {\n      path: '/home',\n      component: () => import('@/components/home'),\n    },\n    {\n      path: '/about',\n      component: () => import('@/components/home'),\n    },\n  ],\n})\n")])])]),n("h2",{attrs:{id:"webpack-分包策略"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#webpack-分包策略"}},[e._v("#")]),e._v(" webpack 分包策略")]),e._v(" "),n("p",[e._v("在 webpack 打包过程中，经常出现 "),n("code",[e._v("vendor.js")]),e._v("， "),n("code",[e._v("app.js")]),e._v(" 单个文件较大的情况，这偏偏又是网页最先加载的文件，这就会使得加载时间过长，从而使得白屏时间过长，影响用户体验。所以我们需要有合理的分包策略。")]),e._v(" "),n("h3",{attrs:{id:"commonschunkplugin"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#commonschunkplugin"}},[e._v("#")]),e._v(" CommonsChunkPlugin")]),e._v(" "),n("p",[e._v("在 Webapck4.x 版本之前，我们都是使用 "),n("code",[e._v("CommonsChunkPlugin")]),e._v(" 去做分离")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("plugins: [\n  new webpack.optimize.CommonsChunkPlugin({\n    name: 'vendor',\n    minChunks: function (module, count) {\n      return (\n        module.resource &&\n        /\\.js$/.test(module.resource) &&\n        module.resource.indexOf(path.join(__dirname, './node_modules')) === 0\n      )\n    },\n  }),\n  new webpack.optimize.CommonsChunkPlugin({\n    name: 'common',\n    chunks: 'initial',\n    minChunks: 2,\n  }),\n]\n")])])]),n("p",[e._v("我们把以下文件单独抽离出来打包")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("node_modules")]),e._v(" 文件夹下的，模块")]),e._v(" "),n("li",[e._v("被 3 个 入口 "),n("code",[e._v("chunk")]),e._v(" 共享的模块")])]),e._v(" "),n("h3",{attrs:{id:"optimization-splitchunks"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#optimization-splitchunks"}},[e._v("#")]),e._v(" optimization.splitChunks")]),e._v(" "),n("p",[e._v("webpack 4 最大的改动就是废除了 "),n("code",[e._v("CommonsChunkPlugin")]),e._v(" 引入了 "),n("code",[e._v("optimization.splitChunks")]),e._v("。如果你的 "),n("code",[e._v("mode")]),e._v(" 是 "),n("code",[e._v("production")]),e._v("，那么 webpack4 就会自动开启 "),n("code",[e._v("Code Splitting")]),e._v("。")]),e._v(" "),n("p",[e._v("它内置的代码分割策略是这样的：")]),e._v(" "),n("ul",[n("li",[e._v("新的 chunk 是否被共享或者是来自 "),n("code",[e._v("node_modules")]),e._v(" 的模块")]),e._v(" "),n("li",[e._v("新的 chunk 体积在压缩之前是否大于 30kb")]),e._v(" "),n("li",[e._v("按需加载 chunk 的并发请求数量小于等于 5 个")]),e._v(" "),n("li",[e._v("页面初始加载时的并发请求数量小于等于 3 个")])]),e._v(" "),n("p",[e._v("虽然在 webpack4 会自动开启 "),n("code",[e._v("Code Splitting")]),e._v("，但是随着项目工程的最大，这往往不能满足我们的需求，我们需要再进行个性化的优化。")]),e._v(" "),n("h3",{attrs:{id:"应用实例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#应用实例"}},[e._v("#")]),e._v(" 应用实例")]),e._v(" "),n("p",[e._v("我们先找到一个优化空间较大的项目来进行操作。这是一个后台管理系统项目，大部分内容由 3-4 个前端开发，平时开发周期较短，且大部分人没有优化意识，只是写好业务代码完成需求，日子一长，造成打包出来的文件较大，大大影响性能。")]),e._v(" "),n("p",[e._v("我们先用 "),n("code",[e._v("webpack-bundle-analyzer")]),e._v(" 分析打包后的模块依赖及文件大小，确定优化的方向在哪。")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc64cbf79557428496a368685ff42de9~tplv-k3u1fbpfcp-watermark.image",alt:""}})]),e._v(" "),n("p",[e._v("然后我们再看下打包出来的 js 文件")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82059f53060248ecabaa870e0d9c70c1~tplv-k3u1fbpfcp-watermark.image",alt:""}})]),e._v(" "),n("p",[e._v("看到这两张图的时候，我内心是崩溃的，槽点如下")]),e._v(" "),n("ul",[n("li",[e._v("打包后生成多个将近 1M 的 js 文件，其中不乏 "),n("code",[e._v("vendor.js")]),e._v(" 首页必须加载的大文件")]),e._v(" "),n("li",[n("code",[e._v("xlsx.js")]),e._v(" 这样的插件没必要使用，导出 excel 更好的方法应该是后端返回文件流格式给前端处理")]),e._v(" "),n("li",[n("code",[e._v("echart")]),e._v(" 和 "),n("code",[e._v("iview")]),e._v(" 文件太大，应该使用 cdn 引入的方法")])]),e._v(" "),n("p",[e._v("吐槽完之后我们就要开始做正事了。正是因为有这么多槽点，我们才更好用来验证我们优化方法的可行性。")]),e._v(" "),n("h4",{attrs:{id:"抽离-echart-和-iview"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#抽离-echart-和-iview"}},[e._v("#")]),e._v(" 抽离 echart 和 iview")]),e._v(" "),n("p",[e._v("由上面分析可知，"),n("code",[e._v("echart")]),e._v(" 和 "),n("code",[e._v("iview")]),e._v(" 文件太大，此时我们就用到 webpack4 的 "),n("code",[e._v("optimization.splitChunks")]),e._v(" 进行代码分割了，把他们单独抽离打包成文件。(为了更好地呈现优化效果，我们先把 xlsx.js 去掉)")]),e._v(" "),n("p",[n("code",[e._v("vue.config.js")]),e._v(" 修改如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("chainWebpack: config => {\n    config.optimization.splitChunks({\n      chunks: 'all',\n      cacheGroups: {\n        vendors: {\n          name: 'chunk-vendors',\n          test: /[\\\\/]node_modules[\\\\/]/,\n          priority: 10,\n          chunks: 'initial'\n        },\n        iview: {\n          name: 'chunk-iview',\n          priority: 20,\n          test: /[\\\\/]node_modules[\\\\/]_?iview(.*)/\n        },\n        echarts: {\n          name: 'chunk-echarts',\n          priority: 20,\n          test: /[\\\\/]node_modules[\\\\/]_?echarts(.*)/\n        },\n        commons: {\n          name: 'chunk-commons',\n          minChunks: 2,\n          priority: 5,\n          chunks: 'initial',\n          reuseExistingChunk: true\n        }\n      }\n    })\n  },\n")])])]),n("p",[e._v("此时我们再用 "),n("code",[e._v("webpack-bundle-analyzer")]),e._v(" 分析一下")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/155bab2a58c74f0db92d04385e62f21d~tplv-k3u1fbpfcp-watermark.image",alt:""}})]),e._v(" "),n("p",[e._v("打包出来的 js 文件")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef0679845a51459e983f24a4a6ee83e2~tplv-k3u1fbpfcp-watermark.image",alt:""}})]),e._v(" "),n("p",[e._v("从这里可以看出我们已经成功把 "),n("code",[e._v("echart")]),e._v(" 和 "),n("code",[e._v("iview")]),e._v(" 单独抽离出来了，同时 "),n("code",[e._v("vendor.js")]),e._v(" 也相应地减小了体积。此外，我们还可以继续抽离其他更多的第三方模块。")]),e._v(" "),n("h4",{attrs:{id:"cdn-方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cdn-方式"}},[e._v("#")]),e._v(" CDN 方式")]),e._v(" "),n("p",[e._v("虽然第三方模块是单独抽离出来了，但是在首页或者相应路由加载时还是要加载这样一个几百 kb 的文件，还是不利于性能优化的。这时，我们可以用 CDN 的方式引入这样插件或者 UI 组件库。")]),e._v(" "),n("ol",[n("li",[e._v("在 "),n("code",[e._v("index.html")]),e._v(" 引入相应 cdn 链接")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<head>\n  <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/iview/3.5.4/styles/iview.css" />\n</head>\n<body>\n  <div id="app"></div>\n  <script src="https://cdn.bootcss.com/vue/2.6.8/vue.min.js"><\/script>\n  <script src="https://cdn.bootcdn.net/ajax/libs/iview/3.5.4/iview.min.js"><\/script>\n  <script src="https://cdn.bootcdn.net/ajax/libs/xlsx/0.16.8/xlsx.mini.min.js"><\/script>\n  <script src="https://cdn.bootcdn.net/ajax/libs/xlsx/0.16.8/cpexcel.min.js"><\/script>\n</body>\n')])])]),n("ol",{attrs:{start:"2"}},[n("li",[n("code",[e._v("vue.config.js")]),e._v(" 配置 "),n("code",[e._v("externals")])])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("configureWebpack: (config) => {\n  config.externals = {\n    vue: 'Vue',\n    xlsx: 'XLSX',\n    iview: 'iView',\n    iView: 'ViewUI',\n  }\n}\n")])])]),n("ol",{attrs:{start:"3"}},[n("li",[e._v("删除之前的引入方式并卸载相应 npm 依赖包")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("npm uninstall vue iview echarts xlsx --save\n")])])]),n("p",[e._v("此时我们在来看一下打包后的情况")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8553fb4e38745148177d780d77b90e4~tplv-k3u1fbpfcp-watermark.image",alt:""}})]),e._v(" "),n("p",[e._v("打包出来的 js 文件")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4bb3f312dd04ff6addf74455607be15~tplv-k3u1fbpfcp-watermark.image",alt:""}})]),e._v(" "),n("p",[e._v("well done ! 这时基本没有打包出大文件了，首页加载需要的 "),n("code",[e._v("vendor.js")]),e._v(" 也只有几十 kb，而且我们还可以进一步优化，就是把 vue 全家桶的一些模块再通过 cdn 的方法引入，比如 "),n("code",[e._v("vue-router")]),e._v("，"),n("code",[e._v("vuex")]),e._v("，"),n("code",[e._v("axios")]),e._v(" 等。这时页面特别是首页加载的性能就得到大大地优化了。")]),e._v(" "),n("h2",{attrs:{id:"推荐文章"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#推荐文章"}},[e._v("#")]),e._v(" 推荐文章")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/6866964944634511368",target:"_blank",rel:"noopener noreferrer"}},[e._v("谈谈数据状态管理和实现一个简易版 vuex"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/6844904193589772301",target:"_blank",rel:"noopener noreferrer"}},[e._v("总结 18 个 webpack 插件，总会有你想要的！"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/6844904152389124103#heading-19",target:"_blank",rel:"noopener noreferrer"}},[e._v("搭建一个 vue-cli4+webpack 移动端框架（开箱即用）"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/6844904168868544525",target:"_blank",rel:"noopener noreferrer"}},[e._v("从零构建到优化一个类似 vue-cli 的脚手架"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/6844903991655022600",target:"_blank",rel:"noopener noreferrer"}},[e._v("封装一个 toast 和 dialog 组件并发布到 npm"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/6844904005286494215",target:"_blank",rel:"noopener noreferrer"}},[e._v("从零开始构建一个 webpack 项目"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/6844904004825120782",target:"_blank",rel:"noopener noreferrer"}},[e._v("总结几个 webpack 打包优化的方法"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/6844904094692278286",target:"_blank",rel:"noopener noreferrer"}},[e._v("总结 vue 知识体系之高级应用篇"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/6844904080960126989",target:"_blank",rel:"noopener noreferrer"}},[e._v("总结 vue 知识体系之实用技巧"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/6844904079164964871",target:"_blank",rel:"noopener noreferrer"}},[e._v("总结 vue 知识体系之基础入门篇"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/6844904066301050893",target:"_blank",rel:"noopener noreferrer"}},[e._v("总结移动端 H5 开发常用技巧（干货满满哦！）"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("本文转自 "),n("a",{attrs:{href:"https://juejin.cn/post/6895546761255845901",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://juejin.cn/post/6895546761255845901"),n("OutboundLink")],1),e._v("，如有侵权，请联系删除。")])])}),[],!1,null,null,null);n.default=s.exports}}]);