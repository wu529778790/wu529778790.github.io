(window.webpackJsonp=window.webpackJsonp||[]).push([[176],{512:function(s,t,a){"use strict";a.r(t);var n=a(4),e=Object(n.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",{attrs:{"data-nodeid":"2"}},[s._v("前面几讲我们从编程思维的角度分析了软件设计哲学。从这一讲开始，我们将深入数据结构这个话题。")]),s._v(" "),t("p",{attrs:{"data-nodeid":"3"}},[s._v("数据结构是计算机中组织和存储数据的特定方式，它的目的是方便且高效地对数据进行访问和修改。数据结构体现了数据之间的关系，以及操作数据的一系列方法。数据又是程序的基本单元，因此无论哪种语言、哪种领域，都离不开数据结构；另一方面，数据结构是算法的基础，其本身也包含了算法的部分内容。也就是说，想要掌握算法，有一个坚固的数据结构基础是必要条件。")]),s._v(" "),t("p",{attrs:{"data-nodeid":"4"}},[s._v("下面我们用 JavaScript 实现几个常见的数据结构。")]),s._v(" "),t("h3",{attrs:{"data-nodeid":"5"}},[s._v("数据结构介绍")]),s._v(" "),t("p",{attrs:{"data-nodeid":"6"}},[s._v("我通常将数据结构分为八大类。")]),s._v(" "),t("ul",{attrs:{"data-nodeid":"7"}},[t("li",{attrs:{"data-nodeid":"8"}},[t("p",{attrs:{"data-nodeid":"9"}},[s._v("数组：Array")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"10"}},[t("p",{attrs:{"data-nodeid":"11"}},[s._v("堆栈：Stack")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"12"}},[t("p",{attrs:{"data-nodeid":"13"}},[s._v("队列：Queue")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"14"}},[t("p",{attrs:{"data-nodeid":"15"}},[s._v("链表：Linked Lists")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"16"}},[t("p",{attrs:{"data-nodeid":"17"}},[s._v("树：Trees")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"18"}},[t("p",{attrs:{"data-nodeid":"19"}},[s._v("图：Graphs")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"20"}},[t("p",{attrs:{"data-nodeid":"21"}},[s._v("字典树：Trie")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"22"}},[t("p",{attrs:{"data-nodeid":"23"}},[s._v("散列表（哈希表）：Hash Tables")])])]),s._v(" "),t("p",{attrs:{"data-nodeid":"24"}},[s._v("我们可以先大体感知一下各种数据结构之间的关系：")]),s._v(" "),t("ul",{attrs:{"data-nodeid":"25"}},[t("li",{attrs:{"data-nodeid":"26"}},[t("p",{attrs:{"data-nodeid":"27"}},[s._v("栈和队列是类似数组的结构，非常多的初级题目要求用数组实现栈和队列，它们在插入和删除的方式上和数组有所差异，但是实现还是非常简单的；")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"28"}},[t("p",{attrs:{"data-nodeid":"29"}},[s._v("链表、树和图这种数据结构的特点是，其节点需要引用其他节点，因此在增/删时，需要注意对"),t("strong",{attrs:{"data-nodeid":"258"}},[s._v("相关前驱和后继节点")]),s._v("的影响；")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"30"}},[t("p",{attrs:{"data-nodeid":"31"}},[s._v("可以从堆栈和队列出发，构建出链表；")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"32"}},[t("p",{attrs:{"data-nodeid":"33"}},[s._v("树和图最为复杂，但它们本质上扩展了链表的概念；")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"34"}},[t("p",{attrs:{"data-nodeid":"35"}},[s._v("散列表的关键是"),t("strong",{attrs:{"data-nodeid":"266"}},[s._v("理解散列函数")]),s._v("，明白依赖散列函数实现保存和定位数据的过程；")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"36"}},[t("p",{attrs:{"data-nodeid":"37"}},[s._v("直观上认为，链表适合记录和存储数据；哈希表和字典树在检索数据以及搜索方面有更大的应用场景。")])])]),s._v(" "),t("p",{attrs:{"data-nodeid":"38"}},[s._v("以上这些“直观感性”的认知并不是“恒等式”，我们将在下面的学习中去印证这些“认知”，这两讲中，你将会看到熟悉的 React、Vue 框架的部分实现，将会看到典型的算法场景，也请你做好相关基础知识的储备。")]),s._v(" "),t("h3",{attrs:{"data-nodeid":"39"}},[s._v("堆栈和队列")]),s._v(" "),t("p",{attrs:{"data-nodeid":"40"}},[s._v("栈和队列是一种"),t("strong",{attrs:{"data-nodeid":"275"}},[s._v("操作受限的线性结构")]),s._v("，它们非常简单，虽然 JavaScript 并没有原生内置这样的数据结构，但是我们可以轻松地模拟出来。")]),s._v(" "),t("p",{attrs:{"data-nodeid":"41"}},[s._v("栈的实现，后进先出 LIFO（Last in、First out）：")]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"42"}},[t("code",{attrs:{"data-language":"java"}},[t("span",{staticClass:"hljs-class"},[t("span",{staticClass:"hljs-keyword"},[s._v("class")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("Stack")]),s._v(" ")]),s._v("{\n  constructor(...args) {\n    "),t("span",{staticClass:"hljs-comment"},[s._v("// 使用数组进行模拟")]),s._v("\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".stack = [...args]\n  }\n  push(...items) {\n    "),t("span",{staticClass:"hljs-comment"},[s._v("// 入栈")]),s._v("\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".stack.push(... items)\n  }\n  pop() {\n   "),t("span",{staticClass:"hljs-comment"},[s._v("// 出栈，从数组尾部弹出一项")]),s._v("\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".stack.pop()\n  }\n  peek() {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".isEmpty()\n        ? undefined\n        : "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".stack["),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".size() - "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v("]\n  }\n  isEmpty() {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".size() == "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("\n  }\n  size() {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".stack.length\n  }\n}\n")])]),s._v(" "),t("p",{attrs:{"data-nodeid":"43"}},[s._v("队列的实现，先进先出 FIFO（First in、First out），“比葫芦画瓢”即可：")]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"44"}},[t("code",{attrs:{"data-language":"java"}},[t("span",{staticClass:"hljs-class"},[t("span",{staticClass:"hljs-keyword"},[s._v("class")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("Queue")]),s._v(" ")]),s._v("{\n  constructor(...args) {\n    "),t("span",{staticClass:"hljs-comment"},[s._v("// 使用数组进行模拟")]),s._v("\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".queue = [...args]\n  }\n  enqueue(...items) {\n    "),t("span",{staticClass:"hljs-comment"},[s._v("// 入队")]),s._v("\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".queue.push(... items)\n  }\n  dequeue() {\n    "),t("span",{staticClass:"hljs-comment"},[s._v("// 出队")]),s._v("\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".queue.shift()\n  }\n  front() {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".isEmpty()\n        ? undefined\n        : "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".queue["),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("]\n  }\n  back() {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".isEmpty()\n        ? undefined\n        : "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".queue["),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".size() - "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v("]\n  }\n  isEmpty() {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".size() == "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("\n  }\n  size() {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".queue.length\n  }\n}\n")])]),s._v(" "),t("p",{attrs:{"data-nodeid":"45"}},[s._v("我们可以看到不管是栈还是队列，都是用数组进行模拟的。数组是最基本的数据结构，但是它的价值是惊人的。我们会在下一讲，进一步介绍栈和队列的应用场景。")]),s._v(" "),t("h3",{attrs:{"data-nodeid":"46"}},[s._v("链表（单向链表和双向链表）")]),s._v(" "),t("p",{attrs:{"data-nodeid":"47"}},[s._v("堆栈和队列都可以利用数组实现，链表和数组一样，也实现了按照一定的顺序存储元素，不同的地方在于链表不能像数组一样通过下标访问，而是"),t("strong",{attrs:{"data-nodeid":"289"}},[s._v("每一个元素都能够通过“指针”指向下一个元素")]),s._v("。我们可以直观地得出结论："),t("strong",{attrs:{"data-nodeid":"290"}},[s._v("链表不需要一段连续的存储空间")]),s._v("，“指向下一个元素”的方式能够更大限度地利用内存。")]),s._v(" "),t("p",{attrs:{"data-nodeid":"48"}},[s._v("根据上述内容，我们可以总结出链表的优点在于：")]),s._v(" "),t("ul",{attrs:{"data-nodeid":"49"}},[t("li",{attrs:{"data-nodeid":"50"}},[t("p",{attrs:{"data-nodeid":"51"}},[s._v("链表的插入和删除操作的时间复杂度是常数级的，我们只需要改变相关节点的指针指向即可；")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"52"}},[t("p",{attrs:{"data-nodeid":"53"}},[s._v("链表可以像数组一样顺序访问，查找元素的时间复杂度是线性的。")])])]),s._v(" "),t("p",{attrs:{"data-nodeid":"54"}},[s._v("要想实现链表，我们需要先对链表进行分类，常见的有"),t("strong",{attrs:{"data-nodeid":"299"}},[s._v("单链表和双向链表")]),s._v("。")]),s._v(" "),t("ul",{attrs:{"data-nodeid":"2077"}},[t("li",{attrs:{"data-nodeid":"2078"}},[t("p",{attrs:{"data-nodeid":"2079"}},[s._v("单链表：单链表是维护一系列节点的数据结构，其特点是：每个节点包含了数据，同时包含指向链表中下一个节点的指针。")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"2080"}},[t("p",{attrs:{"data-nodeid":"2081"}},[s._v("双向链表：不同于单链表，双向链表特点：每个节点分支除了包含其数据以外，还包含了分别指向其前驱和后继节点的指针。")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"2082"}})]),s._v(" "),t("p",{attrs:{"data-nodeid":"2971"}},[t("img",{attrs:{src:"https://s0.lgstatic.com/i/image6/M01/04/F5/CioPOWAvYtuAEfl-AAIhGegvMJU666.png",alt:"图片12.png","data-nodeid":"2974"}})]),s._v(" "),t("p",{attrs:{"data-nodeid":"61"}},[s._v("首先，根据双向链表的特点，我们实现一个节点构造函数（节点类），如下代码：")]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"62"}},[t("code",{attrs:{"data-language":"java"}},[t("span",{staticClass:"hljs-class"},[t("span",{staticClass:"hljs-keyword"},[s._v("class")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("Node")]),s._v(" ")]),s._v("{\n    constructor(data) {\n        "),t("span",{staticClass:"hljs-comment"},[s._v("// data 为当前节点储存的数据")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".data = data\n        "),t("span",{staticClass:"hljs-comment"},[s._v("// next 指向下一个节点")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".next = "),t("span",{staticClass:"hljs-keyword"},[s._v("null")]),s._v("\n        "),t("span",{staticClass:"hljs-comment"},[s._v("// prev 指向前一个节点")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".prev = "),t("span",{staticClass:"hljs-keyword"},[s._v("null")]),s._v("\n    }\n}\n")])]),s._v(" "),t("p",{attrs:{"data-nodeid":"63"}},[s._v("有了节点类，我们来初步实现双向链表类，如下代码：")]),s._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("DoublyLinkedList")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("constructor")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 双向链表开头")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("head "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 双向链表结尾")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("tail "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// ...")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),t("p",{attrs:{"data-nodeid":"65"}},[s._v("接下来，需要实现双向链表原型上的一些方法，这些方法包括以下几种。")]),s._v(" "),t("ul",{attrs:{"data-nodeid":"66"}},[t("li",{attrs:{"data-nodeid":"67"}},[t("p",{attrs:{"data-nodeid":"68"}},[s._v("add：在链表尾部添加一个新的节点，实现如下代码：")])])]),s._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("add")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("item")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 实例化一个节点")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" node "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Node")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("item"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 如果当前链表还没有头")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("!")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("head"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("head "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" node\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("tail "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" node\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n  \n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 如果当前链表已经有了头，只需要在尾部加上该节点")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("else")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 把当前的尾部作为新节点的 prev")]),s._v("\n    node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("prev "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("tail\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 把当前的尾部的 next 指向为新节点 node")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("tail"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("next "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" node\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("tail "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" node\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),t("ul",{attrs:{"data-nodeid":"70"}},[t("li",{attrs:{"data-nodeid":"71"}},[t("p",{attrs:{"data-nodeid":"72"}},[s._v("addAt：在链表指定位置添加一个新的节点，实现如下代码：")])])]),s._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("addAt")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("index"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" item")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n   "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" current "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("head\n\n   "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 维护查找时当前节点的索引")]),s._v("\n   "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" counter "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n   "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" node "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Node")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("item"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n   "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 如果在头部插入")]),s._v("\n   "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("index "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("===")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n     "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("head"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("prev "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" node\n     node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("next "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("head\n     "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("head "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" node\n   "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n   "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 非头部插入，需要从头开始，找寻插入位置")]),s._v("\n   "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("else")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n     "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("while")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("current"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n      current "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" current"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("next\n      "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v(" counter "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("===")]),s._v(" index"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("prev "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" current"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("prev\n        current"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("prev"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("next "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" node\n        node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("next "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" current\n        current"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("prev "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" node\n      "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n      counter"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("++")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),t("ul",{attrs:{"data-nodeid":"74"}},[t("li",{attrs:{"data-nodeid":"75"}},[t("p",{attrs:{"data-nodeid":"76"}},[s._v("remove：删除链表指定数据项节点，实现如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"77"}},[t("code",{attrs:{"data-language":"java"}},[s._v("remove(item) {\n  let current = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v("."),t("span",{staticClass:"hljs-function"},[s._v("head\n  "),t("span",{staticClass:"hljs-title"},[s._v("while")]),s._v(" "),t("span",{staticClass:"hljs-params"},[s._v("(current)")]),s._v(" ")]),s._v("{\n       "),t("span",{staticClass:"hljs-comment"},[s._v("// 找到了目标节点")]),s._v("\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (current.data === item ) {\n      "),t("span",{staticClass:"hljs-comment"},[s._v("// 目标链表只有当前目标项，即目标节点即是链表头又是链表尾")]),s._v("\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (current == "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".head && current == "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".tail) {\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".head = "),t("span",{staticClass:"hljs-keyword"},[s._v("null")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".tail = "),t("span",{staticClass:"hljs-keyword"},[s._v("null")]),s._v("\n      }\n      "),t("span",{staticClass:"hljs-comment"},[s._v("// 目标节点为链表头")]),s._v("\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (current == "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".head ) {\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".head = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".head.next\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".head.prev = "),t("span",{staticClass:"hljs-keyword"},[s._v("null")]),s._v("\n      }\n      "),t("span",{staticClass:"hljs-comment"},[s._v("// 目标节点为链表尾部")]),s._v("\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (current == "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".tail ) {\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".tail = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".tail.prev;\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".tail.next = "),t("span",{staticClass:"hljs-keyword"},[s._v("null")]),s._v(";\n      }\n      "),t("span",{staticClass:"hljs-comment"},[s._v("// 目标节点在链表首尾之间，中部")]),s._v("\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {\n        current.prev.next = current.next;\n        current.next.prev = current.prev;\n      }\n   }\n   current = current.next\n  }\n}\n")])]),s._v(" "),t("ul",{attrs:{"data-nodeid":"78"}},[t("li",{attrs:{"data-nodeid":"79"}},[t("p",{attrs:{"data-nodeid":"80"}},[s._v("removeAt：删除链表指定位置节点，实现如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"81"}},[t("code",{attrs:{"data-language":"java"}},[s._v("removeAt(index) {\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// 都是从“头”开始遍历")]),s._v("\n  let current = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".head\n  let counter = "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v("\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// 删除链表头部")]),s._v("\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (index === "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v(" ) {\n   "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".head = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".head.next\n   "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".head.prev = "),t("span",{staticClass:"hljs-keyword"},[s._v("null")]),s._v("\n  }\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {\n   "),t("span",{staticClass:"hljs-keyword"},[s._v("while")]),s._v("(current) {\n    current = current.next\n    "),t("span",{staticClass:"hljs-comment"},[s._v("// 如果目标节点在链表尾")]),s._v("\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (current == "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".tail) {\n     "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".tail = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".tail.prev\n     "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".tail.next = "),t("span",{staticClass:"hljs-keyword"},[s._v("null")]),s._v("\n    }\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (counter === index) {\n     current.prev.next = current.next\n     current.next.prev = current.prev\n     "),t("span",{staticClass:"hljs-keyword"},[s._v("break")]),s._v("\n    }\n    counter++\n   }\n  }\n}\n")])]),s._v(" "),t("ul",{attrs:{"data-nodeid":"82"}},[t("li",{attrs:{"data-nodeid":"83"}},[t("p",{attrs:{"data-nodeid":"84"}},[s._v("reverse：翻转链表，实现如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"85"}},[t("code",{attrs:{"data-language":"java"}},[s._v("reverse() {\n  let current = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".head\n  let prev = "),t("span",{staticClass:"hljs-function"},[t("span",{staticClass:"hljs-keyword"},[s._v("null")]),s._v("\n  "),t("span",{staticClass:"hljs-title"},[s._v("while")]),s._v(" "),t("span",{staticClass:"hljs-params"},[s._v("(current)")]),s._v(" ")]),s._v("{\n   let next = current.next\n   "),t("span",{staticClass:"hljs-comment"},[s._v("// 前后倒置")]),s._v("\n   current.next = prev\n   current.prev = next\n   prev = current\n   current = next\n  }\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".tail = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".head\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".head = prev\n}\n")])]),s._v(" "),t("ul",{attrs:{"data-nodeid":"86"}},[t("li",{attrs:{"data-nodeid":"87"}},[t("p",{attrs:{"data-nodeid":"88"}},[s._v("swap：交换两个节点数据，实现如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"89"}},[t("code",{attrs:{"data-language":"java"}},[s._v("swap(index1, index2) {\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// 使 index1 始终小于 index2，方便后面查找交换")]),s._v("\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (index1 > index2) {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".swap(index2, index1)\n  }\n  let current = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".head\n  let counter = "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("\n  "),t("span",{staticClass:"hljs-function"},[s._v("let firstNode\n  "),t("span",{staticClass:"hljs-title"},[s._v("while")]),t("span",{staticClass:"hljs-params"},[s._v("(current !== "),t("span",{staticClass:"hljs-keyword"},[s._v("null")]),s._v(")")]),s._v(" ")]),s._v("{\n    "),t("span",{staticClass:"hljs-comment"},[s._v("// 找到第一个节点，先存起来")]),s._v("\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (counter === index1 ){\n        firstNode = current\n    }\n    "),t("span",{staticClass:"hljs-comment"},[s._v("// 找到第二个节点，进行数据交换")]),s._v("\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (counter === index2) {\n      "),t("span",{staticClass:"hljs-comment"},[s._v("// ES 提供了更为简洁的交换数据的方式，这里我们用传统方式实现，更为直观")]),s._v("\n      let temp = current.data\n      current.data = firstNode.data\n      firstNode.data = temp\n    }\n    current = current.next\n    counter++\n  }\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("true")]),s._v("\n}\n")])]),s._v(" "),t("ul",{attrs:{"data-nodeid":"90"}},[t("li",{attrs:{"data-nodeid":"91"}},[t("p",{attrs:{"data-nodeid":"92"}},[s._v("isEmpty：查询链表是否为空，实现如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"93"}},[t("code",{attrs:{"data-language":"java"}},[s._v("isEmpty() {\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".length() < "),t("span",{staticClass:"hljs-number"},[s._v("1")]),s._v("\n}\n")])]),s._v(" "),t("ul",{attrs:{"data-nodeid":"94"}},[t("li",{attrs:{"data-nodeid":"95"}},[t("p",{attrs:{"data-nodeid":"96"}},[s._v("length：查询链表长度，实现如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"97"}},[t("code",{attrs:{"data-language":"java"}},[s._v("length() {\n  let current = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".head\n  let counter = "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// 完整遍历一遍链表")]),s._v("\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("while")]),s._v("(current !== "),t("span",{staticClass:"hljs-keyword"},[s._v("null")]),s._v(") {\n    counter++\n    current = current.next\n  }\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" counter\n}\n")])]),s._v(" "),t("ul",{attrs:{"data-nodeid":"98"}},[t("li",{attrs:{"data-nodeid":"99"}},[t("p",{attrs:{"data-nodeid":"100"}},[s._v("traverse：遍历链表，实现如下代码：")])])]),s._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[s._v("traverse")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("fn")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" current "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("head\n  \n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("while")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("current "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("!==")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 执行遍历时回调 ")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("fn")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("current"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n    current "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" current"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("next\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("true")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),t("p",{attrs:{"data-nodeid":"102"}},[s._v("如上代码，有了上面 length 方法的遍历实现，traverse 也就不难理解了，它接受一个遍历执行函数，在 while 循环中进行调用。")]),s._v(" "),t("ul",{attrs:{"data-nodeid":"103"}},[t("li",{attrs:{"data-nodeid":"104"}},[t("p",{attrs:{"data-nodeid":"105"}},[s._v("find：查找某个节点的索引，实现如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"106"}},[t("code",{attrs:{"data-language":"java"}},[s._v("find(item) {\n  let current = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".head\n  let counter = "),t("span",{staticClass:"hljs-number"},[s._v("0")]),s._v("\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("while")]),s._v("( current ) {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v("( current.data == item ) {\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" counter\n    }\n    current = current.next\n    counter++\n  }\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("false")]),s._v("\n}\n")])]),s._v(" "),t("p",{attrs:{"data-nodeid":"107"}},[s._v("至此，我们就实现了所有双向链表（DoublyLinkedList）的方法。仔细分析整个实现过程，你可以发现：双向链表的实现并不复杂，在手写过程中，需要开发者做到心中有“表”，考虑到当前节点的 next 和 prev 取值，逻辑上还是很简单的。")]),s._v(" "),t("h3",{attrs:{"data-nodeid":"108"}},[s._v("树")]),s._v(" "),t("p",{attrs:{"data-nodeid":"109"}},[s._v("前端开发者应该对树这个数据结构丝毫不陌生，不同于之前介绍的所有数据结构，"),t("strong",{attrs:{"data-nodeid":"334"}},[s._v("树是非线性的")]),s._v("。因为树决定了其存储的数据直接有明确的层级关系，因此对于维护具有层级特性的数据，树是一个天然良好的选择。")]),s._v(" "),t("p",{attrs:{"data-nodeid":"110"}},[s._v("事实上，树有很多种分类，但是它们都具有以下特性：")]),s._v(" "),t("ul",{attrs:{"data-nodeid":"111"}},[t("li",{attrs:{"data-nodeid":"112"}},[t("p",{attrs:{"data-nodeid":"113"}},[s._v("除了根节点以外，所有的节点都有一个父节点；")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"114"}},[t("p",{attrs:{"data-nodeid":"115"}},[s._v("每一个节点都可以有若干子节点，如果没有子节点，则称此节点为叶子节点；")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"116"}},[t("p",{attrs:{"data-nodeid":"117"}},[s._v("一个节点所拥有的叶子节点的个数，称之为该节点的度，因此叶子节点的度为 0；")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"118"}},[t("p",{attrs:{"data-nodeid":"119"}},[s._v("所有节点中，最大的度为整棵树的度；")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"120"}},[t("p",{attrs:{"data-nodeid":"121"}},[s._v("树的最大层次称为树的深度。")])])]),s._v(" "),t("p",{attrs:{"data-nodeid":"122"}},[s._v("我们这里对二叉搜索树展开分析。二叉树算是最基本的树，因为它的结构最简单，每个节点至多包含两个子节点。二叉树又非常有用，因为根据二叉树，我们可以延伸出二叉搜索树（BST）、平衡二叉搜索树（AVL）、红黑树（R/B Tree）等。")]),s._v(" "),t("p",{attrs:{"data-nodeid":"123"}},[s._v("二叉搜索树有以下特性：")]),s._v(" "),t("ul",{attrs:{"data-nodeid":"124"}},[t("li",{attrs:{"data-nodeid":"125"}},[t("p",{attrs:{"data-nodeid":"126"}},[s._v("左子树上所有结点的值均小于或等于它的根结点的值；")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"127"}},[t("p",{attrs:{"data-nodeid":"128"}},[s._v("右子树上所有结点的值均大于或等于它的根结点的值；")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"129"}},[t("p",{attrs:{"data-nodeid":"130"}},[s._v("左、右子树也分别为二叉搜索树。")])])]),s._v(" "),t("p",{attrs:{"data-nodeid":"131"}},[s._v("根据其特性，我们实现二叉搜索树还是应该先构造一个节点类，如下代码：")]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"132"}},[t("code",{attrs:{"data-language":"java"}},[t("span",{staticClass:"hljs-class"},[t("span",{staticClass:"hljs-keyword"},[s._v("class")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("Node")]),s._v(" ")]),s._v("{\n  constructor(data) {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".left = "),t("span",{staticClass:"hljs-keyword"},[s._v("null")]),s._v("\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".right = "),t("span",{staticClass:"hljs-keyword"},[s._v("null")]),s._v("\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".value = data\n  }\n}\n")])]),s._v(" "),t("p",{attrs:{"data-nodeid":"133"}},[s._v("然后我们实现二叉搜索树的以下方法。")]),s._v(" "),t("ul",{attrs:{"data-nodeid":"134"}},[t("li",{attrs:{"data-nodeid":"135"}},[t("p",{attrs:{"data-nodeid":"136"}},[s._v("insertNode：根据一个父节点，插入一个子节点，如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"137"}},[t("code",{attrs:{"data-language":"java"}},[s._v("insertNode(root, newNode) {\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// 根据待插入节点的值的大小，递归调用 this.insertNode")]),s._v("\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (newNode.value < root.value) {\n    (!root.left) ? root.left = newNode : "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".insertNode(root.left, newNode)\n  } "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {\n    (!root.right) ? root.right = newNode : "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".insertNode(root.right, newNode)\n  }\n}\n")])]),s._v(" "),t("ul",{attrs:{"data-nodeid":"138"}},[t("li",{attrs:{"data-nodeid":"139"}},[t("p",{attrs:{"data-nodeid":"140"}},[s._v("insert：插入一个新节点，如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"141"}},[t("code",{attrs:{"data-language":"java"}},[s._v("insert(value) {\n    let newNode = "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Node(value)\n    "),t("span",{staticClass:"hljs-comment"},[s._v("// 判读是否是根节点")]),s._v("\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!"),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".root) {\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".root = newNode\n    } "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {\n     "),t("span",{staticClass:"hljs-comment"},[s._v("// 不是根结点，则直接调用 this.insertNode 方法")]),s._v("\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".insertNode("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".root, newNode)\n    }\n}\n")])]),s._v(" "),t("p",{attrs:{"data-nodeid":"142"}},[s._v("理解这两个方法是理解二叉搜索树的关键，如果你理解了这两个方法，下面的其他方法也就“不在话下”。")]),s._v(" "),t("p",{attrs:{"data-nodeid":"143"}},[s._v("我们可以看到，insertNode 方法先判断目标父节点和插入节点的值，如果插入节点的值更小，则考虑放到父节点的左边，接着递归调用 this.insertNode(root.left, newNode)；如果插入节点的值更大，以此类推即可。insert 方法只是多了一步构造 Node 节点实例，接下来区分有无父节点的情况，调用 this.insertNode 方法即可。")]),s._v(" "),t("ul",{attrs:{"data-nodeid":"144"}},[t("li",{attrs:{"data-nodeid":"145"}},[t("p",{attrs:{"data-nodeid":"146"}},[s._v("removeNode：根据一个父节点，移除一个子节点，如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"147"}},[t("code",{attrs:{"data-language":"java"}},[s._v("removeNode(root, value) {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!root) {\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("null")]),s._v("\n    }\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (value < root.value) {\n      root.left = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".removeNode(root.left, value)\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" root\n    } "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (value > root.value) {\n      root.right = tis.removeNode(root.right, value)\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" root\n    } "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {\n      "),t("span",{staticClass:"hljs-comment"},[s._v("// 找到了需要删除的节点 ")]),s._v("\n      "),t("span",{staticClass:"hljs-comment"},[s._v("// 如果当前 root 节点无左右子节点")]),s._v("\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!root.left && !root.right) {\n        root = "),t("span",{staticClass:"hljs-keyword"},[s._v("null")]),s._v("\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" root\n      }\n      "),t("span",{staticClass:"hljs-comment"},[s._v("// 只有左节点")]),s._v("\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (root.left && !root.right) {\n        root = root.left\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" root\n      }\n      "),t("span",{staticClass:"hljs-comment"},[s._v("// 只有右节点")]),s._v("\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (root.right) {\n        root = root.right\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" root\n      }\n      "),t("span",{staticClass:"hljs-comment"},[s._v("// 有左右两个子节点")]),s._v("\n      let minRight = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".findMinNode(root.right)\n      root.value = minRight.value\n      root.right = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".removeNode(root.right, minRight.value)\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" root\n    }\n  }\n")])]),s._v(" "),t("ul",{attrs:{"data-nodeid":"148"}},[t("li",{attrs:{"data-nodeid":"149"}},[t("p",{attrs:{"data-nodeid":"150"}},[s._v("remove：移除一个节点，如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"151"}},[t("code",{attrs:{"data-language":"java"}},[s._v("remove(value) {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" ("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".root) {\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".removeNode("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".root, value)\n    }\n}\n"),t("span",{staticClass:"hljs-comment"},[s._v("// 找到最小的节点")]),s._v("\n"),t("span",{staticClass:"hljs-comment"},[s._v("// 该方法不断递归，直到找到最左叶子节点即可")]),s._v("\nfindMinNode(root) {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!root.left) {\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" root\n    } "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".findMinNode(root.left)\n    }\n}\n")])]),s._v(" "),t("p",{attrs:{"data-nodeid":"152"}},[s._v("上述代码不难理解，唯一需要说明的是：当需要删除的节点含有左右两个子节点时，因为我们要把当前节点删除，就需要找到合适的“补位”节点，"),t("strong",{attrs:{"data-nodeid":"359"}},[s._v("这个“补位”节点一定在该目标节点的右侧树当中")]),s._v("，因为这样才能保证“补位”节点的值一定大于该目标节点的左侧树所有节点，而该目标节点的左侧树不需要调整；同时为了保证“补位”节点的值一定要小于该目标节点的右侧树值，因此要找的“补位”节点其实就是该目标节点的右侧树当中最小的那个节点。")]),s._v(" "),t("ul",{attrs:{"data-nodeid":"153"}},[t("li",{attrs:{"data-nodeid":"154"}},[t("p",{attrs:{"data-nodeid":"155"}},[s._v("searchNode：根据一个父节点，查找子节点，如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"156"}},[t("code",{attrs:{"data-language":"java"}},[s._v("searchNode(root, value) {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!root) {\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("null")]),s._v("\n    }\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (value < root.value) {\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".searchNode(root.left, value)\n    } "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (value > root.value) {\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".searchNode(root.right, value)\n    }\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" root\n}\n")])]),s._v(" "),t("ul",{attrs:{"data-nodeid":"157"}},[t("li",{attrs:{"data-nodeid":"158"}},[t("p",{attrs:{"data-nodeid":"159"}},[s._v("search：查找节点，如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"160"}},[t("code",{attrs:{"data-language":"java"}},[s._v("search(value) {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!"),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".root) {\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" "),t("span",{staticClass:"hljs-keyword"},[s._v("false")]),s._v("\n    }\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" Boolean("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".searchNode("),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".root, value))\n}\n")])]),s._v(" "),t("ul",{attrs:{"data-nodeid":"161"}},[t("li",{attrs:{"data-nodeid":"162"}},[t("p",{attrs:{"data-nodeid":"163"}},[s._v("preOrder：前序遍历，如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"164"}},[t("code",{attrs:{"data-language":"java"}},[s._v("preOrder(root) {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (root) {\n      console.log(root.value)\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".preOrder(root.left)\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".preOrder(root.right)\n    }\n}\n")])]),s._v(" "),t("ul",{attrs:{"data-nodeid":"165"}},[t("li",{attrs:{"data-nodeid":"166"}},[t("p",{attrs:{"data-nodeid":"167"}},[s._v("InOrder：中序遍历，如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"168"}},[t("code",{attrs:{"data-language":"java"}},[s._v("inOrder(root) {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (root) {\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".inOrder(root.left)\n      console.log(root.value)\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".inOrder(root.right)\n    }\n}\n")])]),s._v(" "),t("ul",{attrs:{"data-nodeid":"169"}},[t("li",{attrs:{"data-nodeid":"170"}},[t("p",{attrs:{"data-nodeid":"171"}},[s._v("PostOrder：后续遍历，如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"172"}},[t("code",{attrs:{"data-language":"java"}},[s._v("postOrder(root) {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (root) {\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".postOrder(root.left)\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".postOrder(root.right)\n      console.log(root.value)\n    }\n}\n")])]),s._v(" "),t("p",{attrs:{"data-nodeid":"173"}},[s._v("上述前、中、后序遍历的区别其实就在于"),t("strong",{attrs:{"data-nodeid":"370"}},[s._v("console.log(root.value) 方法执行的位置")]),s._v("。")]),s._v(" "),t("h3",{attrs:{"data-nodeid":"174"}},[s._v("图")]),s._v(" "),t("p",{attrs:{"data-nodeid":"175"}},[s._v("图是由具有边的节点集合组成的数据结构，图可以是定向的或不定向的。图也是应用最广泛的数据结构之一，真实场景中处处有图。当然更多概念还是需要你先进行了解，尤其是图的几种基本元素。")]),s._v(" "),t("ul",{attrs:{"data-nodeid":"176"}},[t("li",{attrs:{"data-nodeid":"177"}},[t("p",{attrs:{"data-nodeid":"178"}},[s._v("节点：Node")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"179"}},[t("p",{attrs:{"data-nodeid":"180"}},[s._v("边：Edge")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"181"}},[t("p",{attrs:{"data-nodeid":"182"}},[s._v("|V|：图中顶点（节点）的总数")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"183"}},[t("p",{attrs:{"data-nodeid":"184"}},[s._v("|E|：图中的连接总数（边）")])])]),s._v(" "),t("p",{attrs:{"data-nodeid":"185"}},[s._v("这里我们主要实现一个有向图，Graph 类，如下代码：")]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"186"}},[t("code",{attrs:{"data-language":"java"}},[t("span",{staticClass:"hljs-class"},[t("span",{staticClass:"hljs-keyword"},[s._v("class")]),s._v(" "),t("span",{staticClass:"hljs-title"},[s._v("Graph")]),s._v(" ")]),s._v("{\n  constructor() {\n    "),t("span",{staticClass:"hljs-comment"},[s._v("// 使用 Map 数据结构表述图中顶点关系")]),s._v("\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".AdjList = "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Map()\n  }\n}\n")])]),s._v(" "),t("p",{attrs:{"data-nodeid":"187"}},[s._v("我们先通过创建节点，来创建一个图，如下代码：")]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"188"}},[t("code",{attrs:{"data-language":"java"}},[s._v("let graph = "),t("span",{staticClass:"hljs-keyword"},[s._v("new")]),s._v(" Graph();\ngraph.addVertex("),t("span",{staticClass:"hljs-string"},[s._v("'A'")]),s._v(")\ngraph.addVertex("),t("span",{staticClass:"hljs-string"},[s._v("'B'")]),s._v(")\ngraph.addVertex("),t("span",{staticClass:"hljs-string"},[s._v("'C'")]),s._v(")\ngraph.addVertex("),t("span",{staticClass:"hljs-string"},[s._v("'D'")]),s._v(")\n")])]),s._v(" "),t("ul",{attrs:{"data-nodeid":"189"}},[t("li",{attrs:{"data-nodeid":"190"}},[t("p",{attrs:{"data-nodeid":"191"}},[s._v("添加顶点：addVertex，如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"192"}},[t("code",{attrs:{"data-language":"java"}},[s._v("addVertex(vertex) {\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!"),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".AdjList.has(vertex)) {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".AdjList.set(vertex, [])\n  } "),t("span",{staticClass:"hljs-keyword"},[s._v("else")]),s._v(" {\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("throw")]),s._v(" "),t("span",{staticClass:"hljs-string"},[s._v("'vertex already exist!'")]),s._v("\n  }\n}\n")])]),s._v(" "),t("p",{attrs:{"data-nodeid":"193"}},[s._v("这时候，A、B、C、D 顶点都对应一个数组，如下代码所示：")]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"194"}},[t("code",{attrs:{"data-language":"java"}},[s._v("  "),t("span",{staticClass:"hljs-string"},[s._v("'A'")]),s._v(" => [],\n  "),t("span",{staticClass:"hljs-string"},[s._v("'B'")]),s._v(" => [],\n  "),t("span",{staticClass:"hljs-string"},[s._v("'C'")]),s._v(" => [],\n  "),t("span",{staticClass:"hljs-string"},[s._v("'D'")]),s._v(" => []\n")])]),s._v(" "),t("p",{attrs:{"data-nodeid":"195"}},[s._v("数组将用来存储边。我们设计图预计得到如下关系：")]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"196"}},[t("code",{attrs:{"data-language":"java"}},[s._v("Map {\n  "),t("span",{staticClass:"hljs-string"},[s._v("'A'")]),s._v(" => ["),t("span",{staticClass:"hljs-string"},[s._v("'B'")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'C'")]),s._v(", "),t("span",{staticClass:"hljs-string"},[s._v("'D'")]),s._v("],\n  "),t("span",{staticClass:"hljs-string"},[s._v("'B'")]),s._v(" => [],\n  "),t("span",{staticClass:"hljs-string"},[s._v("'C'")]),s._v(" => ["),t("span",{staticClass:"hljs-string"},[s._v("'B'")]),s._v("],\n  "),t("span",{staticClass:"hljs-string"},[s._v("'D'")]),s._v(" => ["),t("span",{staticClass:"hljs-string"},[s._v("'C'")]),s._v("]\n}\n")])]),s._v(" "),t("p",{attrs:{"data-nodeid":"197"}},[s._v("根据以上描述，其实已经可以把图画出来了。addEdge 需要两个参数：一个是顶点，一个是连接对象 Node。我们看看添加边是如何实现的。")]),s._v(" "),t("ul",{attrs:{"data-nodeid":"198"}},[t("li",{attrs:{"data-nodeid":"199"}},[t("p",{attrs:{"data-nodeid":"200"}},[s._v("添加边：addEdge，如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"201"}},[t("code",{attrs:{"data-language":"java"}},[s._v(" addEdge(vertex, node) {\n    if (this.AdjList.has(vertex)) {\n      if (this.AdjList.has(node)){\n        let arr = this.AdjList.get(vertex)\n        if (!arr.includes(node)){\n          arr.push(node)\n        }\n      } else {\n        throw `Can't add non-existing vertex ->'${node}'`\n      }\n    } else {\n      throw `You should add '${vertex}' first`\n    }\n}\n")])]),s._v(" "),t("p",{attrs:{"data-nodeid":"202"}},[s._v("理清楚数据关系，我们就可以打印图了，其实就是一个很简单的 for…of 循环：")]),s._v(" "),t("ul",{attrs:{"data-nodeid":"203"}},[t("li",{attrs:{"data-nodeid":"204"}},[t("p",{attrs:{"data-nodeid":"205"}},[s._v("打印图：print，如下代码：")])])]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"206"}},[t("code",{attrs:{"data-language":"java"}},[s._v("print() {\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// 使用 for of 遍历并打印 this.AdjList")]),s._v("\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" (let [key, value] of "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".AdjList) {\n    console.log(key, value)\n  }\n}\n")])]),s._v(" "),t("p",{attrs:{"data-nodeid":"207"}},[s._v("剩下的内容就是遍历图了。遍历分为广度优先算法（BFS）和深度优先搜索算法（DFS）。我们先来看下广度优先算法（BFS）。")]),s._v(" "),t("p",{attrs:{"data-nodeid":"208"}},[s._v("广度优先算法遍历，如下代码：")]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"209"}},[t("code",{attrs:{"data-language":"java"}},[s._v("createVisitedObject() {\n  let map = {}\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" (let key of "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".AdjList.keys()) {\n    arr[key] = "),t("span",{staticClass:"hljs-keyword"},[s._v("false")]),s._v("\n  }\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" map\n}\nbfs (initialNode) {\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// 创建一个已访问节点的 map")]),s._v("\n  let visited = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".createVisitedObject()\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// 模拟一个队列")]),s._v("\n  let queue = []\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// 第一个节点已访问")]),s._v("\n  visited[initialNode] = "),t("span",{staticClass:"hljs-keyword"},[s._v("true")]),s._v("\n  "),t("span",{staticClass:"hljs-comment"},[s._v("// 第一个节点入队列")]),s._v("\n  queue.push(initialNode)\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("while")]),s._v(" (queue.length) {\n    let current = queue.shift()\n    console.log(current)\n     "),t("span",{staticClass:"hljs-comment"},[s._v("// 获得该节点的其他节点关系")]),s._v("\n    let arr = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".AdjList.get(current)\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" (let elem of arr) {\n      "),t("span",{staticClass:"hljs-comment"},[s._v("// 如果当前节点没有访问过")]),s._v("\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!visited[elem]) {\n        visited[elem] = "),t("span",{staticClass:"hljs-keyword"},[s._v("true")]),s._v("\n        queue.push(elem)\n      }\n    }\n  }\n}\n")])]),s._v(" "),t("p",{attrs:{"data-nodeid":"210"}},[s._v("如上代码所示，我们来进行简单总结。广度优先算法（BFS），是一种"),t("strong",{attrs:{"data-nodeid":"393"}},[s._v("利用队列实现的搜索算法")]),s._v("。对于图来说，就是从起点出发，对于每次出队列的点，都要遍历其四周的点。")]),s._v(" "),t("p",{attrs:{"data-nodeid":"211"}},[s._v("因此 BFS 的实现步骤：")]),s._v(" "),t("ul",{attrs:{"data-nodeid":"212"}},[t("li",{attrs:{"data-nodeid":"213"}},[t("p",{attrs:{"data-nodeid":"214"}},[s._v("起始节点作为起始，并初始化一个空对象——visited；")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"215"}},[t("p",{attrs:{"data-nodeid":"216"}},[s._v("初始化一个空数组，该数组将模拟一个队列；")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"217"}},[t("p",{attrs:{"data-nodeid":"218"}},[s._v("将起始节点标记为已访问；")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"219"}},[t("p",{attrs:{"data-nodeid":"220"}},[s._v("将起始节点放入队列中；")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"221"}},[t("p",{attrs:{"data-nodeid":"222"}},[s._v("循环直到队列为空。")])])]),s._v(" "),t("p",{attrs:{"data-nodeid":"223"}},[s._v("深度优先算法，如下代码：")]),s._v(" "),t("pre",{staticClass:"lang-java",attrs:{"data-nodeid":"224"}},[t("code",{attrs:{"data-language":"java"}},[s._v("createVisitedObject() {\n  let map = {}\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" (let key of "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".AdjList.keys()) {\n    arr[key] = "),t("span",{staticClass:"hljs-keyword"},[s._v("false")]),s._v("\n  }\n  "),t("span",{staticClass:"hljs-keyword"},[s._v("return")]),s._v(" map\n}\n "),t("span",{staticClass:"hljs-comment"},[s._v("// 深度优先算法")]),s._v("\n dfs(initialNode) {\n    let visited = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".createVisitedObject()\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".dfsHelper(initialNode, visited)\n  }\n  dfsHelper(node, visited) {\n    visited[node] = "),t("span",{staticClass:"hljs-keyword"},[s._v("true")]),s._v("\n    console.log(node)\n    let arr = "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".AdjList.get(node)\n    "),t("span",{staticClass:"hljs-comment"},[s._v("// 遍历节点调用 this.dfsHelper")]),s._v("\n    "),t("span",{staticClass:"hljs-keyword"},[s._v("for")]),s._v(" (let elem of arr) {\n      "),t("span",{staticClass:"hljs-keyword"},[s._v("if")]),s._v(" (!visited[elem]) {\n        "),t("span",{staticClass:"hljs-keyword"},[s._v("this")]),s._v(".dfsHelper(elem, visited)\n      }\n    }\n  }\n}\n")])]),s._v(" "),t("p",{attrs:{"data-nodeid":"225"}},[s._v("如上代码，对于深度优先搜索算法（DFS），我把它总结为：“不撞南墙不回头”，从起点出发，先把一个方向的点都遍历完才会改变方向。换成程序语言就是：“"),t("strong",{attrs:{"data-nodeid":"406"}},[s._v("DFS 是利用递归实现的搜索算法")]),s._v("”。因此 DFS 的实现过程：")]),s._v(" "),t("ul",{attrs:{"data-nodeid":"226"}},[t("li",{attrs:{"data-nodeid":"227"}},[t("p",{attrs:{"data-nodeid":"228"}},[s._v("起始节点作为起始，创建访问对象；")])]),s._v(" "),t("li",{attrs:{"data-nodeid":"229"}},[t("p",{attrs:{"data-nodeid":"230"}},[s._v("调用辅助函数递归起始节点。")])])]),s._v(" "),t("p",{attrs:{"data-nodeid":"231"}},[s._v("BFS 的实现重点在于队列，而 DFS 的重点在于递归，这是它们的本质区别。")]),s._v(" "),t("h3",{attrs:{"data-nodeid":"232"}},[s._v("总结")]),s._v(" "),t("p",{attrs:{"data-nodeid":"233"}},[s._v("这一讲我们介绍了和前端最为贴合的几种数据结构，事实上数据结构更重要的是应用，我希望你能够做到：在需要的场景，能够想到最为适合的数据结构处理问题。请你务必掌握好这些内容，接下来的几讲都需要对数据结构有一个较为熟练的掌握和了解。我们马上进入数据结构的应用学习。")]),s._v(" "),t("p",{attrs:{"data-nodeid":"234"}},[s._v("本讲内容总结如下：")]),s._v(" "),t("p",{staticClass:"te-preview-highlight",attrs:{"data-nodeid":"3789"}},[t("img",{attrs:{src:"https://s0.lgstatic.com/i/image6/M00/04/F5/CioPOWAvYweAUX2mAAHhvq_M9XU847.png",alt:"如何利用 JavaScript 实现经典数据结构？.png","data-nodeid":"3792"}})]),s._v(" "),t("p",{attrs:{"data-nodeid":"236"}},[s._v("随着需求的复杂度上升，前端工程师越来越离不开数据结构。是否能够掌握这个难点内容，将是进阶的重要考量。下一讲，我们将解析数据结构在前端中的具体应用场景，来帮助你加深理解，做到灵活应用。")]),s._v(" "),t("hr"),s._v(" "),t("h3",{attrs:{id:"精选评论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#精选评论"}},[s._v("#")]),s._v(" 精选评论")]),s._v(" "),t("h5",{attrs:{id:"宇"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#宇"}},[s._v("#")]),s._v(" **宇")]),s._v(" "),t("blockquote",[t("p",[s._v("bfs dfs其实就是层序遍历和前序遍历，树是一种特殊的有向图")])]),s._v(" "),t("h5",{attrs:{id:"聪"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#聪"}},[s._v("#")]),s._v(" *聪")]),s._v(" "),t("blockquote",[t("p",[s._v("【createVisitedObject() { let map = {} for (let key of this.AdjList.keys()) { arr[key] = false } return map}】-------这里arr[key] = false，应是 map[key] = false ？")])]),s._v(" "),t("h6",{attrs:{id:"讲师回复"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#讲师回复"}},[s._v("#")]),s._v("     讲师回复")]),s._v(" "),t("blockquote",[t("p",[s._v("    是，这里是个 typo")])]),s._v(" "),t("h5",{attrs:{id:"聪-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#聪-2"}},[s._v("#")]),s._v(" *聪")]),s._v(" "),t("blockquote",[t("p",[s._v("老师，文中【这个“补位”节点一定在该目标节点的右侧树当中】是不是不一定？既然可以选右侧最小的节点，那我要选左侧最大的节点也行吧？")])]),s._v(" "),t("h6",{attrs:{id:"讲师回复-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#讲师回复-2"}},[s._v("#")]),s._v("     讲师回复")]),s._v(" "),t("blockquote",[t("p",[s._v("    右侧 > 左侧")])])])}),[],!1,null,null,null);t.default=e.exports}}]);